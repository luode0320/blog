### Redis缓存击穿穿透雪崩

在使用 Redis 作为缓存时，经常会遇到“缓存击穿”、“缓存穿透”和“缓存雪崩”这三个问题。

这些问题会导致系统性能下降，甚至引发服务中断。下面分别介绍这些问题的原因以及解决方案。

### 1. 缓存击穿（Cache Punch-through）

#### 描述

缓存击穿指的是某个热点数据在缓存中**失效的瞬间**，**大量请求直接打到后端数据库**，导致数据库压力骤增的现象。

注意: 前提是, 本来是没失效的, **缓存是存在的, 突然某个时间失效**。

#### 原因

- 热点数据：某个非常热门的数据在缓存中失效。
- 大量并发请求：在数据失效的瞬间，大量并发请求直接访问后端数据库。

#### 解决方案

1. **分布式锁**：
    - 使用分布式锁（如 Redis 的 SETNX 或 REDISLOCK）来控制并发请求。**当数据失效时，只有一个请求能够获取锁并从数据库加载数据
      **，其他请求等待锁释放后再尝试。
2. **同步锁（Mutex）**：推荐
    - 使用**同步锁来**更新数据。例如，当数据失效时，设置一个锁，每个节点都只有一个请求能够获取锁并从数据库加载数据,
      其他请求等待锁释放后再尝试。
3. **延长过期时间**：
    - 在数据即将过期时，延长其过期时间，同时设置一个标志位。当其他请求访问时，如果发现标志位存在，则**返回旧数据或空值**
      ，直到数据更新完成。

### 2. 缓存穿透（Cache Penetration）

#### 描述

缓存穿透指的是**查询一个不存在**的数据，由于缓存中也没有该数据，导致每次请求都要到数据库查询，增加了数据库的压力。

注意: 前提是, **缓存从来都没有存在过**。

#### 原因

- 请求不存在的数据：客户端请求的数据在缓存和数据库中均不存在。
- 大量并发请求：每次请求都需要访问数据库，导致数据库压力增大。

#### 解决方案

1. **分布式锁缓存空值**：
    - 使用分布式锁（如 Redis 的 SETNX 或 REDISLOCK）来控制并发请求。将查询结果为空的数据也缓存起来，并设置合理的过期时间。这样后续请求可以直接从缓存中获取空值，减少数据库访问。
2. **同步锁（Mutex）缓存空值**：推荐
    - 使用**互斥锁来**更新数据。例如，当数据失效时，设置一个互斥锁标志，将查询结果为空的数据也缓存起来，并设置合理的过期时间。这样后续请求可以直接从缓存中获取空值，减少数据库访问。
3. **布隆过滤器（Bloom Filter）**：
    - 使用布隆过滤器预先过滤掉不存在的数据，减少无效请求到达数据库。

### 3. 缓存雪崩（Cache Avalanche）

#### 描述

缓存雪崩指的是**大量数据在同一时间段内失效**，导致大量请求打到后端数据库，造成数据库压力骤增。

#### 原因

- 大量数据同时失效：由于设置的数据过期时间相同，导致大量数据在同一时刻失效。
- 大量并发请求：大量请求同时打到数据库，导致数据库压力过大。

#### 解决方案

1. **分散过期时间**：
    - 为数据设置随机的过期时间，避免大量数据同时失效。例如，可以在基础过期时间的基础上**加上一个随机偏移量**。
2. **分布式锁**:
    - 分布式锁解决所有键的缓存击穿问题。
3. **降级处理**：
    - 当缓存出现异常或大量数据失效时，可以采用降级处理，**返回默认值或预先准备好的静态页面**，减少对数据库的依赖。
4. **熔断机制**：
    - 引入熔断机制，当缓存请求出现异常或数据库压力过大时，**暂时屏蔽这部分请求**，待恢复正常后再重新开放。