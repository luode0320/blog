### Redis 如何实现延时队列

Redis 可以通过多种方式实现延时队列。

延时队列是一种特殊的队列，它可以确保消息在特定的时间点之后才会被处理。

### 使用 ZSet 实现延时队列

ZSet 可以用来存储带有时间戳的任务。每个任务都有一个分数（通常是时间戳），Redis 会根据分数自动排序。

这种方法的优点是可以方便地获取即将到期的任务。

#### 示例代码

```GO
package main

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/go-redis/redis/v8"
)

func main() {
	// 创建一个 Redis 客户端实例
	rdb := redis.NewClient(&redis.Options{
		Addr:     "192.168.2.22:6379", // Redis 地址
		Password: "",                  // 密码
		DB:       0,                   // 数据库索引，默认为 0
	})

	// 设置上下文
	ctx := context.Background()

	// 开始监听频道
	go listenForNewTasks(ctx, rdb)

	// 给订阅者一点时间来启动
	time.Sleep(1 * time.Second)

	// 添加带有时间戳的任务到队列
	addDelayedTasks(ctx, rdb, 10) // 添加 50 个任务

	// 从队列中获取即将到期的任务
	fmt.Println("开始从队列中获取即将到期的任务...")
	time.Sleep(30 * time.Second) // 模拟处理任务的时间延迟
}

// 将带有时间戳的任务添加到队列
func addDelayedTasks(ctx context.Context, rdb *redis.Client, count int) {
	index := 1
	for k := 1; k <= 5; k++ {
		for i := 0; i < count; i++ {
			task := fmt.Sprintf("task%d", index)
			delay := time.Duration(i+1) * time.Second
			addDelayedTask(ctx, rdb, task, delay)
			index++
		}
	}
}

// 将单个带有时间戳的任务添加到队列
func addDelayedTask(ctx context.Context, rdb *redis.Client, task string, delay time.Duration) {
	now := time.Now().UnixNano() + int64(delay)
	score := float64(now) // 使用时间戳作为分数
	err := rdb.ZAdd(ctx, "queue:delayed", &redis.Z{Score: score, Member: task}).Err()
	if err != nil {
		log.Fatalf("无法添加任务到队列: %v", err)
	}
	log.Println("添加任务:", task, now)

	// 发布消息到频道
	err = rdb.Publish(ctx, "task-channel", "new-task-added").Err()
	if err != nil {
		log.Fatalf("无法发布消息到频道: %v", err)
	}
}

// 监听频道并处理消息
func listenForNewTasks(ctx context.Context, rdb *redis.Client) {
	// 创建一个 waitgroup 来管理多个 goroutines
	var wg sync.WaitGroup
	pubsub := rdb.Subscribe(ctx, "task-channel")
	defer pubsub.Close()

	numConsumers := 5 // 你可以根据需要调整消费者的数量

	for _ = range pubsub.Channel() {
		// 创建多个 goroutines 来订阅频道
		for i := 0; i < numConsumers; i++ {
			wg.Add(1)
			go func(id int) {
				defer wg.Done()
				// 处理消息
				task := getDelayedTask(ctx, rdb)
				if task == "" {
					return
				}
				log.Printf("消费者 %d 取出任务执行: %s\n", id, task)
			}(i)
		}
		wg.Wait()
	}
}

// 从队列中获取即将到期的任务
func getDelayedTask(ctx context.Context, rdb *redis.Client) string {
	// 获取当前时间戳, 只要是设置的时间戳小于当前时间戳的, 都算到了延迟时间了
	now := float64(time.Now().UnixNano())

	// 从 Sorted Set 中弹出具有最小分数的成员
	members, err := rdb.ZPopMin(ctx, "queue:delayed").Result()
	if err != nil {
		if err == redis.Nil {
			return ""
		}
		return ""
	}

	if len(members) > 0 {
		firstMember := members[0]
		if firstMember.Score < now {
			return firstMember.Member.(string)
		} else {
			// 计算剩余时间并休眠
			delay := time.Duration(firstMember.Score - now)
			time.Sleep(time.Nanosecond * delay)
			// 休眠结束后再次尝试获取任务
			return firstMember.Member.(string)
		}
	}

	return ""
}
```

步骤总结

1. 初始化 Redis 客户端

2. 添加带有时间戳的任务到队列

3. 将单个带有时间戳的任务添加到ZSet队列

4. 监听频道并处理消息

5. 从队列中获取即将到期的任务

运行结果:

```sh
2024/09/27 01:32:50 添加任务: task1 1727371971393207700
2024/09/27 01:32:50 添加任务: task2 1727371972400178800 
2024/09/27 01:32:50 添加任务: task3 1727371973401178800 
2024/09/27 01:32:50 添加任务: task4 1727371974401178800 
2024/09/27 01:32:50 添加任务: task5 1727371975401679300 
2024/09/27 01:32:50 添加任务: task6 1727371976401679300 
2024/09/27 01:32:50 添加任务: task7 1727371977402179300 
2024/09/27 01:32:50 添加任务: task8 1727371978402179300 
2024/09/27 01:32:50 添加任务: task9 1727371979402679300 
2024/09/27 01:32:50 添加任务: task10 1727371980402679300
2024/09/27 01:32:50 添加任务: task11 1727371971403179400
2024/09/27 01:32:50 添加任务: task12 1727371972403179400
2024/09/27 01:32:50 添加任务: task13 1727371973403679600
2024/09/27 01:32:50 添加任务: task14 1727371974403679600
2024/09/27 01:32:50 添加任务: task15 1727371975404179700
2024/09/27 01:32:50 添加任务: task16 1727371976404179700
2024/09/27 01:32:50 添加任务: task17 1727371977404679700
2024/09/27 01:32:50 添加任务: task18 1727371978404679700
2024/09/27 01:32:50 添加任务: task19 1727371979405179800
2024/09/27 01:32:50 添加任务: task20 1727371980405179800
2024/09/27 01:32:50 添加任务: task21 1727371971405680000
2024/09/27 01:32:50 添加任务: task22 1727371972405680000
2024/09/27 01:32:50 添加任务: task23 1727371973406180000
2024/09/27 01:32:50 添加任务: task24 1727371974406679700
2024/09/27 01:32:50 添加任务: task25 1727371975407180300
2024/09/27 01:32:50 添加任务: task26 1727371976407180300
2024/09/27 01:32:50 添加任务: task27 1727371977407680300
2024/09/27 01:32:50 添加任务: task28 1727371978407680300
2024/09/27 01:32:50 添加任务: task29 1727371979408180100
2024/09/27 01:32:50 添加任务: task30 1727371980408180100
2024/09/27 01:32:50 添加任务: task31 1727371971408680100
2024/09/27 01:32:50 添加任务: task32 1727371972408680100
2024/09/27 01:32:50 添加任务: task33 1727371973409180600
2024/09/27 01:32:50 添加任务: task34 1727371974409180600
2024/09/27 01:32:50 添加任务: task35 1727371975409680600
2024/09/27 01:32:50 添加任务: task36 1727371976409680600
2024/09/27 01:32:50 添加任务: task37 1727371977410180200
2024/09/27 01:32:50 添加任务: task38 1727371978410180200
2024/09/27 01:32:50 添加任务: task39 1727371979410680700
2024/09/27 01:32:50 添加任务: task40 1727371980410680700
2024/09/27 01:32:50 添加任务: task41 1727371971411180800
2024/09/27 01:32:50 添加任务: task42 1727371972411180800
2024/09/27 01:32:50 添加任务: task43 1727371973411680900
2024/09/27 01:32:50 添加任务: task44 1727371974411680900
2024/09/27 01:32:50 添加任务: task45 1727371975412181000
2024/09/27 01:32:50 添加任务: task46 1727371976412181000
2024/09/27 01:32:50 添加任务: task47 1727371977412680600
2024/09/27 01:32:50 添加任务: task48 1727371978412680600
2024/09/27 01:32:50 添加任务: task49 1727371979413181200
2024/09/27 01:32:50 添加任务: task50 1727371980413681400
开始从队列中获取即将到期的任务...
2024/09/27 01:32:51 消费者 2 取出任务执行: task1
2024/09/27 01:32:52 消费者 4 取出任务执行: task2
2024/09/27 01:32:52 消费者 3 取出任务执行: task12
2024/09/27 01:32:52 消费者 1 取出任务执行: task41
2024/09/27 01:32:52 消费者 2 取出任务执行: task21
2024/09/27 01:32:52 消费者 4 取出任务执行: task31
2024/09/27 01:32:52 消费者 0 取出任务执行: task11
2024/09/27 01:32:52 消费者 4 取出任务执行: task32
2024/09/27 01:32:52 消费者 0 取出任务执行: task22
2024/09/27 01:32:52 消费者 1 取出任务执行: task42
2024/09/27 01:32:53 消费者 3 取出任务执行: task3
2024/09/27 01:32:53 消费者 2 取出任务执行: task13
2024/09/27 01:32:53 消费者 0 取出任务执行: task23
2024/09/27 01:32:53 消费者 4 取出任务执行: task43
2024/09/27 01:32:53 消费者 1 取出任务执行: task33
2024/09/27 01:32:54 消费者 2 取出任务执行: task14
2024/09/27 01:32:54 消费者 3 取出任务执行: task4
2024/09/27 01:32:54 消费者 0 取出任务执行: task24
2024/09/27 01:32:54 消费者 4 取出任务执行: task34
2024/09/27 01:32:54 消费者 2 取出任务执行: task44
2024/09/27 01:32:55 消费者 3 取出任务执行: task5
2024/09/27 01:32:55 消费者 1 取出任务执行: task15
2024/09/27 01:32:55 消费者 1 取出任务执行: task25
2024/09/27 01:32:55 消费者 4 取出任务执行: task45
2024/09/27 01:32:55 消费者 2 取出任务执行: task35
2024/09/27 01:32:56 消费者 3 取出任务执行: task16
2024/09/27 01:32:56 消费者 0 取出任务执行: task6
2024/09/27 01:32:56 消费者 0 取出任务执行: task26
2024/09/27 01:32:56 消费者 3 取出任务执行: task46
2024/09/27 01:32:56 消费者 1 取出任务执行: task36
2024/09/27 01:32:57 消费者 4 取出任务执行: task17
2024/09/27 01:32:57 消费者 2 取出任务执行: task7
2024/09/27 01:32:57 消费者 0 取出任务执行: task47
2024/09/27 01:32:57 消费者 4 取出任务执行: task27
2024/09/27 01:32:57 消费者 2 取出任务执行: task37
2024/09/27 01:32:58 消费者 3 取出任务执行: task18
2024/09/27 01:32:58 消费者 1 取出任务执行: task8
2024/09/27 01:32:58 消费者 2 取出任务执行: task28
2024/09/27 01:32:58 消费者 0 取出任务执行: task48
2024/09/27 01:32:58 消费者 4 取出任务执行: task38
2024/09/27 01:32:59 消费者 1 取出任务执行: task19
2024/09/27 01:32:59 消费者 3 取出任务执行: task9
2024/09/27 01:32:59 消费者 2 取出任务执行: task49
2024/09/27 01:32:59 消费者 1 取出任务执行: task39
2024/09/27 01:32:59 消费者 4 取出任务执行: task29
2024/09/27 01:33:00 消费者 3 取出任务执行: task10
2024/09/27 01:33:00 消费者 0 取出任务执行: task20
2024/09/27 01:33:00 消费者 0 取出任务执行: task40
2024/09/27 01:33:00 消费者 2 取出任务执行: task50
2024/09/27 01:33:00 消费者 1 取出任务执行: task30

```

