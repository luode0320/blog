# 分表后⾮sharding_key的查询怎么处理，分表后的排序？

1. 可以做⼀个**mapping**表，⽐如这时候商家要查询订单列表怎么办呢？
2. 不带user_id查询的话你总不能扫全表吧？
3. 所以我们可以做⼀个映射关系表，保存商家和⽤户的关系，查询的时候先通过商家查询到⽤户列表，再通过user_id去查询。

2. 宽表，对数据实时性要求不是很⾼的场景，⽐如查询订单列表，可以把订单表同步到离线（实时） 数仓，再基于数仓去做成⼀张宽表，再基于其他如es提供查询服务。

3. 数据量不是很⼤的话，⽐如后台的⼀些查询之类的，也可以通过多线程扫表，然后再聚合结果的⽅式来做。或者异步的形式也是可以的。

union

排序字段是唯⼀索引：

● ⾸先第⼀⻚的查询：将各表的结果集进⾏合并，然后再次排序

● 第⼆⻚及以后的查询，需要传⼊上⼀⻚排序字段的最后⼀个值，及排序⽅式。

● 根据排序⽅式，及这个值进⾏查询。如排序字段date，上⼀⻚最后值为3，排序⽅式降序。查询的时

候sql为select ... from table where date < 3 order by date desc limit 0,10。这样再将⼏个表的结果合并排序即可。 