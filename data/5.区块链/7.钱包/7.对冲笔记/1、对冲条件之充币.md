# 币池向币安充币



# 1. 币安余额不够了

有一个预警值, 如果币安的余额低于预警值, 触发兑出

- 每次兑换都会检查, 是由兑换触发的

```java
// 获取币安钱包资产池当前币种的余额数量
BigDecimal assetVolume = walletBalanceMap.get(buildBalanceKey(
    reqDTO.getRName(),
    reqDTO.getRNetwork(),
    reqDTO.getRContractAddress()));


// 6. 检查币安资产池是否不足，并在不足时触发资产补充任务(补充到交易所)。
// 此方法用于检查资产池的余额是否低于 初始数量与预警线（比例）的乘积。
// 如果余额不足，则记录警告日志，并在系统允许对冲的情况下，执行资产补充任务。
if (assetVolume.compareTo(networkConfig.getInitVolume().multiply(networkConfig.getWarningLevel())) < 0) {
    log.warn("coin pool lack, asset = {}, network config = {},allow hedge = {}", assetVolume,
             JSON.toJSONString(networkConfig), SystemStatusUtil.isAllowHedging());

    // 如果系统允许对冲操作
    if (SystemStatusUtil.isAllowHedging()) {
        // 更新对冲的时间戳
        SystemStatusUtil.updateHedgeTimestamp();
        // 执行资产补充任务
        taskPoolExecutor.executeRunnableTask(new HedgingRechargeTask(
            ellipalHedgingConfig,
            TransferTriggerTypeEnum.COIN_POOL_LACK.getCode(),
            networkConfigService.getFullNetworkConfigs(),
            hedgeOrderService));
    }
    // 返回 false 表示资产池不足, 返回等待下一次调用
    return Boolean.FALSE;
}
```

# 2.币安合约保证金不足, 触发对冲

```java
// 如果当前保证金率大于或等于合约对冲比率(0.8)，则执行合约保证金预警, 将资金池多余的币充值到交易所
if (curMarginRate.compareTo(futureHedgeRate) >= 0) {
    log.warn("current margin rate is greater than future hedge rate, current margin rate is {} , futureHedgeRate = {}", curMarginRate, futureHedgeRate);

    // 执行对冲操作: 币安合约保证金达到预警, 将资金池多余的币充值到交易所
    doHedging(TransferTriggerTypeEnum.MARGIN_BALANCE_WARNING.getCode());
    return;
}


/**
 * 执行对冲操作(现货/合约)
 *
 * @param triggerType 触发类型
 */
private void doHedging(String triggerType) {
    // 更新对冲服务状态为不可用
    SystemStatusUtil.updateHedgeServiceStatus(false);
    // 更新对冲时间戳
    SystemStatusUtil.updateHedgeTimestamp();
    // 获取所有自有兑换币种配置
    List<InternalNetworkConfig> transferOutConfigs = networkConfigService.getFullNetworkConfigs();
    // 提交对冲充值任务(现货/合约), 将资金池多余的币充值到交易所
    taskPoolExecutor.executeRunnableTask(new HedgingRechargeTask(
        ellipalHedgingConfig,
        triggerType,
        transferOutConfigs,
        hedgeOrderService));
}
```

# 3. 大额兑出, 币安钱不够

对于兑出, 会用等价的钱再币安买入需要兑出的现货

如果兑出的钱价值大于币安的余额, 那么币安肯定无法买入同等价值的兑入的币种, 触发对冲

- 每次兑换都会检查, 是由兑换触发的

```java
// 计算待处理订单总量
// 如果存在已经收到钱, 但还没有开始换, 可以汇总所有未处理的, 一次性交易, 省gas费
BigDecimal pendingVolume = BigDecimal.ZERO;
Optional<BigDecimal> pendingVolumeOptional = pendingOrderList.stream()
    .map(InternalExchangeOrder::getActualToAmount) // 实际转出数量
    .reduce(BigDecimal::add); // 汇总
if (pendingVolumeOptional.isPresent()) {
    pendingVolume = pendingVolumeOptional.get();
}

// 检查待处理订单加上本次转移金额是否超过币安资产池余额(补充到交易所)
if (pendingVolume.add(transferAmount).compareTo(assetVolume) >= 0) { // todo:优化fee
    log.info(
        "coin pool lack ,asset = {} ,pendingVolume = {}, need transferAmount = {}, config = {} , allow hedge = {}",
        assetVolume, pendingVolume, transferAmount, JSON.toJSONString(networkConfig),
        SystemStatusUtil.isAllowHedging());
    // 如果系统允许对冲操作
    if (SystemStatusUtil.isAllowHedging()) {
        // 更新对冲的时间戳
        SystemStatusUtil.updateHedgeTimestamp();
        // 执行资产补充任务
        taskPoolExecutor.executeRunnableTask(new HedgingRechargeTask(
            ellipalHedgingConfig,
            TransferTriggerTypeEnum.COIN_POOL_LACK.getCode(),
            networkConfigService.getFullNetworkConfigs(),
            hedgeOrderService));
    }
    return Boolean.FALSE;
}
```

# 4.手动对冲

```java
/**
 * 手动对冲
 */
public Boolean manualHedge(){
    if (!SystemStatusUtil.isAllowHedging()) {
        return Boolean.FALSE;
    }
    log.info("manual hedge begin");
    SystemStatusUtil.updateHedgeServiceStatus(false);
    SystemStatusUtil.updateHedgeTimestamp();
    List<InternalNetworkConfig> transferOutConfigs = networkConfigService.getFullNetworkConfigs();
    taskPoolExecutor.executeRunnableTask(new HedgingRechargeTask(ellipalHedgingConfig, TransferTriggerTypeEnum.MANUAL.getCode(),transferOutConfigs,hedgeOrderService));
    return Boolean.TRUE;
}
```

