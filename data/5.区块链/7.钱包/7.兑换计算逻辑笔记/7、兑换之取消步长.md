# 取消步长

![image-20250113184649598](../../../picture/image-20250113184649598.png)



币对兑换步长限制放开: 

- 超过步长的部分，先截取尾数，计算这部分占整单的比例，如果已超过设置的费率，则不接此单，交给其他交易所；
- 如果未超过设置的费率，则计算剩余应收的收益，正常接单

```
前提条件: 
BTC: 合约步长0.001
ETH: 合约步长0.001
BTC_ETH: 0.00368_0.10878

- 用户兑换BTC=0.00368; 对冲 BTC=0.003, 截取尾数 BTC=0.00068
- 取消步长之前: 0.00368 * 0.045(收费4.5%) = 0.0001656
	- 理论上最大收费的数量 = 兑出数量 * 0.045(收费策略)
	- 如果 理论上最大收费的数量 大于 被截断的兑出数量小数部分 -> 说明被截断的部分可以全部抹除, 包含在收费比例中
	- 如果 理论上最大收费的数量 小于 被截断的兑出数量小数部分 -> 说明被截断的部分价值占比太高了, 截断用户亏损太多, 此时不接单
	
(截断后的兑出数量 + 被截断的兑出数量小数部分) * y收费策略 = (截断后的兑出数量 * x剩余收费策略) + 被截断的兑出数量小数部分
求: (A + B) * y = A * x + B
解: x = y - (B / A) * (1 - y)
	- x剩余收费策略 = y收费策略 - (被截断的兑出数量小数部分 /  截断后的兑出数量) * (1 - y收费策略)
```

```java
            // 3.抹除步长
            // 获取兑出币步长信息
            InternalNetworkConfig networkConfigOut = networkConfigService.getNetworkConfig(
                    reqDTO.getLName(),
                    reqDTO.getLNetwork(),
                    reqDTO.getLContractAddress());

            // 抹除根据兑出币合约步长的尾数
            StepUtil separateDecimal = StepUtil.truncateAndSeparateDecimal(amount, networkConfigOut.getFutureAmountStep());
            if (separateDecimal == null) {
                log.error("**********计算兑入数量错误:{}({})_{}({}) 兑出数量抹除步长后为0: 兑出数量: {}, 步长: {}",
                        reqDTO.getLName(), reqDTO.getLNetwork(), reqDTO.getRName(), reqDTO.getRNetwork(), amount, networkConfigOut.getFutureAmountStep());
                return null;
            }
            // 截断后的兑出数量
            BigDecimal truncatedAmount = separateDecimal.getTruncatedAmount();
            // 被截断的兑出数量小数部分
            BigDecimal truncatedDecimalPart = separateDecimal.getTruncatedDecimalPart();

            // 理论上最大收费的数量 = 兑出数量 * 0.045(收费策略)
            // 如果 理论上最大收费的数量 > 被截断的兑出数量小数部分 -> 说明被截断的部分可以全部抹除, 可以包含在收费比例中
            // 如果 理论上最大收费的数量 < 被截断的兑出数量小数部分 -> 说明被截断的部分价值占比太高了, 截断用户亏损太多, 此时不接单
            BigDecimal bigAmount = amount.multiply(exchangeFeeRate);
            if (bigAmount.compareTo(truncatedDecimalPart) < 0) {
                log.error("**********计算兑入数量错误:{}({})_{}({}) 兑出数量: {}, 步长: {}, 收费比例: {}%, 最大收费的数量 小于 被截断的兑出数量小数部分: 最大收费的兑出数量: {}, 被截断的兑出数量小数部分: {}",
                        reqDTO.getLName(), reqDTO.getLNetwork(), reqDTO.getRName(), reqDTO.getRNetwork(),
                        amount, networkConfigOut.getFutureAmountStep(), originalProportion, bigAmount.toPlainString(), truncatedDecimalPart.toPlainString());
                return null;
            }
            // (截断后的兑出数量 + 被截断的兑出数量小数部分) * y收费策略(交易所+公司) = (截断后的兑出数量 * x剩余收费策略) + 被截断的兑出数量小数部分
            // 求: (A + B) * y = A * x + B
            // 解: x = y - (B / A) * (1 - y)
            //	- x剩余收费策略 = y收费策略 - (被截断的兑出数量小数部分 /  截断后的兑出数量) * (1 - y收费策略)
            BigDecimal remainingStrategy = exchangeFeeRate.subtract((truncatedDecimalPart.divide(truncatedAmount, 8, RoundingMode.HALF_DOWN)).multiply((BigDecimal.ONE.subtract(exchangeFeeRate))));
            String remainingProportion = remainingStrategy.multiply(new BigDecimal(100)).setScale(2, RoundingMode.HALF_UP).toPlainString();
```



# 最大可抹除的小数

**最大可抹除的小数 = 兑出数量 * 0.045(收费策略)**



> 例1(失败): ETH_BTC

- ETH(兑出数量) = 0.037222
- ETH 步长 = 0.001
- ETH 抹除小数部分 = 0.000222

最大可抹除的小数 = 0.037222 * 0.045(收费策略) = 0.00167499
- 0.00167499 <  0.000222(ETH 抹除小数部分)
- 最大可抹除小数 **小于** 当前兑出小数
- 不可抹除, 此单不接



> 例2(成功): ETH_BTC

- ETH(兑出数量) = 0.037111
- ETH 步长 = 0.001
- ETH 抹除小数部分 = 0.000111

最大可抹除的小数 = 0.037111 * 0.045(收费策略) = 0.001669995

- 0.001669995 > 0.000111(ETH 抹除小数部分)
- 最大可抹除小数 **大于** 当前兑出小数
- 可抹除, 接单

