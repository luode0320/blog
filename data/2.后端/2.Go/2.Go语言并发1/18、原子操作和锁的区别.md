# 简介

原子操作由底层硬件 CPU 支持，而锁则由操作系统的调度器实现。

- 锁应当用来保护一段逻辑，对于一个变量更新的保护。

- 原子操作通常执行上会更有效率，并且更能利用计算机多核的优势

  - 如果要更新的是一个复合对象，则应当使用 atomic.Value 封装好的实现。

  

# 原子操作

原子操作是一种低级的同步机制，用于执行一些简单的并发操作，如增加一个计数器或更新一个变量的值。

原子操作是不可中断的，这意味着在执行过程中，不会被其他 goroutine 或操作系统切换到另一个任务。

原子操作在执行时，CPU 会确保操作的完整性，即操作要么全部完成，要么根本不执行。

#### 优点：

- **速度更快**：原子操作通常比锁快，因为它们不需要进行上下文切换或内核态的系统调用。
- **避免死锁**：原子操作简单且不可中断，所以不会造成死锁。

#### 缺点：

- **功能有限**：原子操作通常只适用于单一变量的简单操作，如读取、写入、加减、比较并交换等。
- **不适用复杂逻辑**：对于需要执行一系列相关操作才能保证数据一致性的情况，原子操作往往无法满足需求。



# 锁

锁是一种高级的同步机制，用于保护共享资源不被同时访问，它可以是互斥锁 Mutex 或读写锁 RWMutex。

锁可以允许一个 goroutine 排他性地访问共享资源，而其他 goroutine 必须等待锁释放。

#### 优点：

- **适用范围广**：锁可以用于保护复杂的共享数据结构或一系列操作的原子性。
- **灵活**：锁可以适应多种不同的并发场景和需求。

#### 缺点：

- **性能开销大**：获取和释放锁涉及到上下文切换和可能的阻塞，这会增加程序的运行时间。
- **死锁风险**：不当使用锁可能导致死锁，即两个或多个 goroutine 相互等待对方释放锁，结果都无法继续执行。



# 示例

## 使用原子操作

```go
package main

import (
	"sync/atomic"
	"fmt"
)

func main() {
	var count int64 = 0

	// 增加计数器
	atomic.AddInt64(&count, 1)
	fmt.Println(count) // 输出 1
}
```



## 使用互斥锁 Mutex

```go
package main

import (
	"sync"
	"fmt"
)

func main() {
	var count int = 0
	var mutex sync.Mutex

	// 加锁，增加计数器，然后解锁
	mutex.Lock()
	count++
	mutex.Unlock()
	fmt.Println(count) // 输出 1
}
```

