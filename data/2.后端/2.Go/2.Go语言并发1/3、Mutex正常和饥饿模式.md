# 简介

在 Go 语言中，`sync.Mutex` 是一个用于同步访问共享资源的互斥锁。

从 Go 1.9 版本开始，`Mutex` 引入了两种操作模式：

- 正常模式（Normal Mode）
- 饥饿模式（Starvation Mode）

这两种模式是为了平衡锁的竞争效率和公平性。



# 正常模式(非公平锁)

在正常模式下，`Mutex` 使用一种**非公平锁**的策略。

- 正常模式下，所有等待锁的 goroutine 按照 FIFO（先进先出）顺序等待。
- 唤醒的 goroutine 不会直接拥有锁，而是会和正在执行的 goroutine 同时竞争锁。

- 正在执行的 goroutine 更容易抢占：因为它正在 CPU 上执行，所以刚刚唤醒的 goroutine有很大可能在锁竞争中失败。
  - 在这种情况下，这个被唤醒的 goroutine 又会加入到等待队列的前面再次被阻塞。





# 饥饿模式(公平锁)

饥饿模式是一种更**公平的锁**获取策略，它旨在防止 goroutines 饿死（starvation），即长期无法获取锁的情况。

- 为了解决了等待 goroutine 队列的长尾问题
- 饥饿模式下，直接由 `unlock` 把锁交给等待队列中排在第一位的 goroutine (队头)
- 同时，饥饿模式下，新进来的 goroutine **不会参与抢锁也不会进入自旋状态**，会直接进入等待队列的尾部。
- 这样很好的解决了老的 goroutine 一直抢不到锁的场景。


当等待锁的 goroutine 的等待时间超过了特定的阈值（默认为 1 毫秒），`Mutex` 将自动切换到饥饿模式。

或者当前队列只剩下一个 goroutine 的时候，Mutex 切换到饥饿模式。



# 总结

1. 正常模式和饥饿模式之间的切换是自动的，由 Go 运行时根据锁的竞争情况动态决定。
   - 正常模式下的性能是最好的，goroutine 可以连续多次获取锁
   - 正常模式提供高吞吐量，适合大多数场景

2. 饥饿模式提供更好的公平性，防止 goroutines 长期无法获取锁
   - 饥饿模式解决了取锁公平的问题，但是性能会下降


