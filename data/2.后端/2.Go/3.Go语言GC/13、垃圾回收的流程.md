## 简介

Go 语言的垃圾回收（GC）是一个自动化的内存管理系统，它负责跟踪不再使用的内存并释放这些内存以供再次使用。

Go 的垃圾回收机制采用了一种称为 **并发标记-清除** 的算法，该算法可以在程序运行时并发地进行垃圾回收，以减少停顿时间并提高程序的整体性能。

## 五个阶段

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：

|             阶段             |          说明          | 赋值器状态 |
|:--------------------------:|:--------------------:|:-----:|
| 初始标记:  gcMarkRootPrepare() |     根对象标记, 开启写屏障     |  STW  |
|   并发标记: gcBgMarkWorker()   |       并发遍历标记队列       |  并发   |
| 标记终止: gcMarkTermination()  | 标记队列遍历完成, 最终标记，停止写屏障 |  STW  |
|      清理回收: bgsweep()       |   唤醒后台垃圾回收线程, 回收垃圾   |  并发   |

关键函数的简要说明：

- **sysmon(): 超时唤醒垃圾回收goroutine**
- **mallocgc(): 当堆内存使用达到一定阈值时，触发垃圾回收**
- **gcBgMarkWorker(): 并发标记**
- **gcDrain(): 执行扫描工作，即黑化灰色对象**
- **gcMarkTermination(): 执行标记终止**
- **gcControllerState.commit**: 准备垃圾回收，更新阈值等。
- **bgsweep(): 启动后台清扫 goroutine**

## 源码分析

具体到源码层面，Go 的垃圾回收涉及到多个文件和函数，包括但不限于 `runtime/mgc.go`、`runtime/mgcsweep.go`
和 `runtime/mgcmark.go` 等文件

## 基本流程

1. **初始化**: 垃圾回收系统初始化，包括设置初始的堆大小、配置参数等。
2. **检测**: 检测堆内存的使用情况，判断是否需要进行垃圾回收。
3. **准备**: 准备垃圾回收，包括更新状态、设置阈值等。
4. **暂停**: 暂停所有的 goroutine，以确保一致性。
5. **标记**: 标记所有可达的对象。
6. **清理**: 清理未标记的对象。
7. **恢复**: 恢复 goroutine 的执行。
8. **反馈**: 更新垃圾回收的状态和参数，为下一次垃圾回收做准备

## 详细流程

### 1. 初始化GC

初始化阶段包括设置初始的堆大小、配置参数等。Go 的垃圾回收配置参数可以在运行时通过 `debug.SetGCPercent` 进行更改。

`src/runtime/proc.go`

#### schedinit(): 初始化 GC 垃圾回收入口

```go
// 启动序列如下：
//
// 调用 runtime.osinit
// 调用 runtime.schedinit
// 创建并排队新的 G
// 调用 runtime.mstart
// 新的 G 调用 runtime.main
func schedinit() {
	...
	gcinit()         // 初始化 GC（垃圾回收）。
    ...
}
```

#### gcinit(): 初始化 GC 垃圾回收

```go
// 函数初始化 Go 语言的垃圾回收系统。
func gcinit() {
	// 确保了 workbuf 的大小与预定义的大小相匹配，以保证最佳性能
	if unsafe.Sizeof(workbuf{}) != _WorkbufSize {
		throw("size of Workbuf is suboptimal")
	}

	// 设置清扫状态: 第一个垃圾回收周期不需要清扫。
	sweep.active.state.Store(sweepDrainedMask)

	// 初始化垃圾回收步调状态:
	// 使用环境变量 GOGC 来设置初始的 gcPercent 值。
	// 使用环境变量 GOMEMLIMIT 来设置初始的 memoryLimit 值。
	gcController.init(readGOGC(), readGOMEMLIMIT())

	// 初始化工作信号量。
	work.startSema = 1
	work.markDoneSema = 1

	// 初始化锁。
	lockInit(&work.sweepWaiters.lock, lockRankSweepWaiters) // 用于同步清扫等待队列
	lockInit(&work.assistQueue.lock, lockRankAssistQueue)   // 用于同步协助队列
	lockInit(&work.wbufSpans.lock, lockRankWbufSpans)       // 用于同步工作缓冲区跨度
}
```

其中比较重要的两个垃圾回收的调优变量:

- `GOGC`: 设置初始的 gcPercent 值, 使用百分比控制垃圾回收的频率
- `GOMEMLIMIT`: 置初始的 memoryLimit 值, 运行时的最大堆内存限制

**gcController.init()初始化垃圾回收步调状态**

```go
// 初始化垃圾回收步调状态:
// 使用环境变量 GOGC 来设置初始的 gcPercent 值, 使用百分比控制垃圾回收的频率。
// 使用环境变量 GOMEMLIMIT 来设置初始的 memoryLimit 值, 运行时的最大堆内存限制。
gcController.init(readGOGC(), readGOMEMLIMIT())
```

```go
// 方法初始化垃圾回收控制器的状态。
// gcPercent 是从环境变量 GOGC 读取的初始垃圾回收百分比。
// memoryLimit 是从环境变量 GOMEMLIMIT 读取的初始最大堆内存限制。
func (c *gcControllerState) init(gcPercent int32, memoryLimit int64) {
	c.heapMinimum = defaultHeapMinimum // 设置初始的最小堆大小。默认: 4194304 == 4 MB
	c.triggered = ^uint64(0)           // 初始化触发阈值为最大值，表示垃圾回收尚未触发。
	c.setGCPercent(gcPercent)          // 设置初始的垃圾回收百分比。
	c.setMemoryLimit(memoryLimit)      // 设置初始的最大堆内存限制。
	c.commit(true)                     // 重新计算所有步调参数，这些参数用于导出垃圾回收的触发阈值和堆的目标大小。

	// 注意: 不需要调用 traceHeapGoal。在初始化期间，跟踪功能从未启用。
	// 注意: 无需调用 revise；在初始化期间没有启用垃圾回收。
}
```

```go
// 函数读取环境变量 GOGC 的值，并将其转换为 int32 类型返回。
// 使用百分比控制垃圾回收的频率
// 如果 GOGC 的值为 "off"，则返回 -1；如果 GOGC 是一个有效的整数，则返回该整数；
// 否则，返回默认值 100。
func readGOGC() int32 {
	// 获取 GOGC 环境变量的值。
	p := gogetenv("GOGC")

	// 检查 GOGC 是否设置为 "off"。
	if p == "off" {
		// 如果 GOGC 设置为 "off"，则返回 -1，表示关闭垃圾回收百分比。
		return -1
	}

	// 尝试将 GOGC 的值转换为 int32 类型。
	if n, ok := atoi32(p); ok {
		return n
	}

	// 如果 GOGC 的值不是 "off" 也不是有效的整数，则返回默认值 100。
	return 100
}
```

```go
// 函数读取环境变量 GOMEMLIMIT 的值，并将其转换为 int64 类型返回。
// 运行时的最大堆内存限制
// 如果 GOMEMLIMIT 的值为空字符串或 "off"，则返回 maxInt64（表示没有限制）；
// 如果 GOMEMLIMIT 是一个有效的字节数量，则返回该字节数量；
// 如果 GOMEMLIMIT 的值格式错误，则抛出异常。
func readGOMEMLIMIT() int64 {
	// 获取 GOMEMLIMIT 环境变量的值。
	p := gogetenv("GOMEMLIMIT")

	// 检查 GOMEMLIMIT 是否为空字符串或设置为 "off"。
	if p == "" || p == "off" {
		// 如果 GOMEMLIMIT 设置为空字符串或 "off"，则返回 maxInt64，表示没有内存限制。
		return maxInt64
	}

	// 尝试将 GOMEMLIMIT 的值转换为字节数量。
	n, ok := parseByteCount(p)
	if !ok {
		print("GOMEMLIMIT=", p, "\n")
		throw("malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`")
	}

	// 如果转换成功，则返回转换后的字节数量。
	return n
}
```

```go
// 重新计算所有步调参数，这些参数用于导出垃圾回收的触发阈值和堆的目标大小。
//
// 这个方法可以在任何时候被调用。如果垃圾回收正在进行并发阶段，它将调整该阶段的步调。
//
// isSweepDone 应该是调用 isSweepDone() 的结果，除非我们在测试中或我们知道我们正在执行垃圾回收周期。
//
// 这个方法依赖于 gcPercent、gcController.heapMarked 和 gcController.heapLive。这些值必须是最新的。
//
// 如果垃圾回收已启用，调用者必须在调用此方法后调用 gcControllerState.revise。
//
// 必须持有 mheap_.lock 锁或停止世界。
func (c *gcControllerState) commit(isSweepDone bool) {
	if !c.test {
		assertWorldStoppedOrLockHeld(&mheap_.lock)
	}

	if isSweepDone {
		// 清扫已完成，因此无需考虑触发阈值的任何限制。
		c.sweepDistMinTrigger.Store(0)
	} else {
		// 并发清扫发生在从 gcController.heapLive 到触发阈值的堆增长中。
		// 确保清扫器有足够的跑道，如果它没有足够的空间。
		c.sweepDistMinTrigger.Store(c.heapLive.Load() + sweepMinHeapDistance)
	}

	// 计算下一次垃圾回收的目标大小，该目标是在上一个周期开始时的存活堆基础上，
	// 增长了 GOGC/100 的比例，再加上非堆来源的垃圾回收工作所需的额外空间。
	gcPercentHeapGoal := ^uint64(0)

	// 从 gcPercent 中加载当前的垃圾回收百分比设置。
	if gcPercent := c.gcPercent.Load(); gcPercent >= 0 {
		// 计算 gcPercentHeapGoal，即下一次垃圾回收的目标大小。
		// c.heapMarked 表示上次垃圾回收后标记的存活堆大小
		// c.lastStackScan.Load() 和 c.globalsScan.Load() 分别表示上次扫描栈和全局变量所消耗的空间
		gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*uint64(gcPercent)/100
	}
	// 应用最小堆大小。它是基于 gcPercent 定义的，并且只能通过调用 commit 的函数来更新。
	if gcPercentHeapGoal < c.heapMinimum {
		gcPercentHeapGoal = c.heapMinimum
	}
	// 存储计算得到的 gcPercentHeapGoal。
	c.gcPercentHeapGoal.Store(gcPercentHeapGoal)

	// 计算我们希望垃圾回收拥有的跑道量，使用我们对 cons/mark 比率的估计。
	//
	// 思路是采用我们预期的扫描工作，并乘以 cons/mark 比率来确定完成该扫描工作所需的时间，
	// 以字节分配的形式表示。这给了我们垃圾回收的跑道。
	//
	// 但是，cons/mark 比率是以每 CPU 秒的速率比率表示的，而在这里我们关心的是 CPU 资源
	// 在应用程序和垃圾回收之间分配的相对速率。
	//
	// 总结来说，我们拥有 B / cpu-ns，而我们想要的是 B / ns。我们通过乘以我们期望的 CPU 资源分配来获得它。
	// 我们选择以 GOMAXPROCS * fraction 的形式表达 CPU 资源。需要注意的是，因为我们这里处理的是比率，
	// 我们可以省略 CPU 核心的数量，因为它们会在分子和分母中出现并相互抵消。
	// 因此，这基本上只是根据我们期望的资源分配来“加权”cons/mark 比率。
	//
	// 此外，通过设置跑道使得 CPU 资源按照这种方式分配，假设 cons/mark 比率是正确的，
	// 我们就使得这种资源分配成为现实。
	c.runway.Store(uint64((c.consMark * (1 - gcGoalUtilization) / (gcGoalUtilization)) * float64(c.lastHeapScan+c.lastStackScan.Load()+c.globalsScan.Load())))
}
```

##### 垃圾回收计算公式说明

```go
gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*uint64(gcPercent)/100
```

**详细解释计算公式**:

- `c.heapMarked`: 上次垃圾回收后标记的存活堆大小。这是当前存活的对象所占用的内存总量。
- `c.lastStackScan.Load()`: 上次扫描栈所消耗的空间。这是因为栈上的对象也需要被扫描，以便确定它们是否仍然可达。
- `c.globalsScan.Load()`: 上次扫描全局变量所消耗的空间。全局变量同样需要被扫描以确定它们是否仍然可达。
- `gcPercent`: 垃圾回收百分比设置。这是一个配置参数，用于指定垃圾回收的目标是在堆大小增长到多少百分比时启动。

假设 `c.heapMarked` 为 100 MB，`c.lastStackScan.Load()` 为 10 MB，`c.globalsScan.Load()` 为 5 MB，`gcPercent` 为 80。

- `c.heapMarked` = 100 MB
- `c.lastStackScan.Load()` = 10 MB
- `c.globalsScan.Load()` = 5 MB
- `gcPercent` = 80%

计算过程如下：

1. 总和 = `c.heapMarked` + `c.lastStackScan.Load()` + `c.globalsScan.Load()` = 100 MB + 10 MB + 5 MB = 115 MB
2. 增长量 = `uint64(gcPercent)` / 100 * 总和 = 80 / 100 * 115 MB = 92 MB
3. `gcPercentHeapGoal` = `c.heapMarked` + 增长量 = 100 MB + 92 MB = 192 MB

因此，`gcPercentHeapGoal` 为 192 MB，这意味着当堆大小增长到 192 MB 时，垃圾回收将会启动。

#### forcegchelper(): 单独启动了一个goroutine执行垃圾回收, 但是会阻塞

`src/runtime/proc.go`

```go
// 初始化 forcegc 辅助 goroutine
func init() {
	go forcegchelper()
}

// forcegchelper 函数是一个辅助 goroutine，用于处理强制 GC 的逻辑。
func forcegchelper() {
	// 为 forcegc 结构体分配一个 goroutine。forcegc是全局变量。
	forcegc.g = getg()
	// 初始化 forcegc 的锁。
	lockInit(&forcegc.lock, lockRankForcegc)

	// 无限循环，持续处理强制 GC。
	for {
		// 加锁以确保对 forcegc 结构体的操作是原子的。
		lock(&forcegc.lock)

		// 检查是否处于空闲状态。
		if forcegc.idle.Load() {
			// 如果处于空闲状态，抛出错误，因为不应该在此时进入空闲状态。
			throw("forcegc: phase error")
		}

		// 将 forcegc.idle 设置为 true，表示 GC 处于空闲状态。
		forcegc.idle.Store(true)

        // 释放锁并让出 CPU 时间片，等待 sysmon() 被唤醒。
		goparkunlock(&forcegc.lock, waitReasonForceGCIdle, traceBlockSystemGoroutine, 1)

		// 这个 goroutine 明确地被 sysmon 唤醒。
		if debug.gctrace > 0 {
			// 如果启用了 GC 跟踪，输出一条消息表示 GC 被强制触发。
			println("GC forced")
		}

		// 根据时间触发条件启动一个新的 GC 周期。
		// 这是一个完全并发的 GC 周期。
		// gcTriggerTime: 强制gc
		gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})  // 超时2分钟强制启动垃圾回收
	}
}
```

创建一个单独的`goroutine`专门用于垃圾回收, 无限循环, 但是会阻塞, 不要通过 `sysmon()`监控线程唤醒才能真正执行垃圾回收。

### 2. 启动 GC

1. 垃圾回收系统会监控堆内存的使用情况。强制超时时间是2分钟。
2. 当堆内存使用达到一定阈值时，就会触发垃圾回收。阈值可以通过环境变量 `GOGC` 或 `debug.SetGCPercent` 设置。

#### sysmon(): 超时唤醒垃圾回收goroutine

`src/runtime/proc.go`

在 Go 语言运行时中，`sysmon` 是一个后台监控线程，它的主要职责是监控和维护运行时环境的健康状态。

`sysmon` 线程在运行时初始化阶段被创建，并在整个程序执行期间持续运行。

```go
// 负责监控和维护整个运行时系统的健康状态;
// 在无需 P 的情况下运行，因此不允许写屏障。
//
//go:nowritebarrierrec
func sysmon() {
	...
	// 死循环, 并设置一定的休眠, 避免 cpu 过高
	for {
		// 根据 idle 的值调整延迟。
		if idle == 0 {
			delay = 20 // 初始延迟为 20 微秒。
		} else if idle > 50 {
			delay *= 2 // 如果 idle 大于 50 微秒，延迟翻倍。
		}
		if delay > 10*1000 {
			delay = 10 * 1000 // 如果 idle 大于 10 毫秒，最大延迟为 10 毫秒。
		}

		// 以微秒为单位的睡眠函数，实现功能为线程在指定的微秒时间内进入睡眠状态
		usleep(delay)

		...
		// 根据不同的触发条件来决定是否需要启动一个新的 GC 周期。
		// 创建临时 gcTrigger 实例: 创建一个临时的 gcTrigger 实例，其 kind 为 gcTriggerTime 强制gc标识，now 字段为当前时间。
		// 调用 test 方法: 调用 gcTrigger 实例的 test 方法来检查是否需要触发超时2分钟的强制 GC。
		// 检查是否处于空闲状态: 检查 forcegc.idle 是否为 true，即 GC 是否处于空闲状态, 才允许强制gc
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && forcegc.idle.Load() { // test(): 根据不同的触发条件来决定是否需要启动一个新的 GC 周期。
			lock(&forcegc.lock) // 加锁以确保对 forcegc 结构体的操作是原子的。

			forcegc.idle.Store(false) // 将 forcegc.idle 设置为 false，表示 GC 不再处于空闲状态。
			var list gList            // 创建一个 gList 结构体，用于存放需要注入的 goroutine。
			list.push(forcegc.g)      // 将 forcegc.g 添加到 gList 中。
			injectglist(&list)        // 将 forcegc.g 注入到运行队列中，使其可以被调度执行。

			// 解锁以释放对 forcegc 结构体的独占访问。
			unlock(&forcegc.lock)
		}
		...
	}
}
```

**test(): 根据不同的触发条件来决定是否需要启动一个新的 GC 周期。**

- 这里使用`gcTriggerTime`: 类型, 也就是如果上一次`GC`的时间**超过了2分钟**没有执行, 则强制唤醒垃圾回收`goroutine`

#### mallocgc(): 当堆内存使用达到一定阈值时，触发垃圾回收

```go
// 函数分配一个大小为 size 的对象。
// 小对象从每个 P 缓存的空闲列表中分配。
// 大对象（> 32 kB）直接从堆上分配。
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
	...
	shouldhelpgc := false // 标记是否触发 GC 垃圾回收。
	...
	// 如果 size 小于 32k
	if size <= maxSmallSize {
		// 如果小于 16 字节
		if noscan && size < maxTinySize {
			// 小型分配器。
			...
			// 分配新块: 如果不适合现有块，则分配一个新的 maxTinySize 大小的块。
			span = c.alloc[tinySpanClass] // 根据SpanClass分配
			v := nextFreeFast(span)       // 返回下一个空闲对象（如果一个对象快速可用）
			// 如果找不到位置，则使用 c.nextFree(tinySpanClass) 从中央列表mcentral中获取位置
			if v == 0 {
				v, span, shouldhelpgc = c.nextFree(tinySpanClass)
			}
			...
		} else {
			// 分配小对象: 16字节 < size < 32k
			...
			size = uintptr(class_to_size[sizeclass]) // 获取实际大小
			spc := makeSpanClass(sizeclass, noscan)  // 创建 span 类
			span = c.alloc[spc]                      // 分配 span
			v := nextFreeFast(span)                  // 返回下一个空闲对象（如果一个对象快速可用）
			// 如果找不到位置，则使用 c.nextFree(tinySpanClass) 从中央列表mcentral中获取位置
			if v == 0 {
				v, span, shouldhelpgc = c.nextFree(spc)
			}
			...
		}
	} else {
		// 分配大对象: size > 32k

		shouldhelpgc = true // 必须触发 gc 垃圾回收
		...
	}
	...
	// 如果 shouldhelpgc 为 true，则可能触发 GC。
	// 1. 如果 size 是小对象(<32k), 但是MCache 缓存不够, 需要从中央列表mcentral中获取位置时, 触发gc
	// 2. 如果 size 是大对象(>32k), 触发gc
	if shouldhelpgc {
		// 表示当堆内存大小达到由控制器计算出的触发堆大小时，应该开始一个新的垃圾回收周期。
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
			gcStart(t) // 堆内存分配对象, 启动垃圾回收
		}
	}
	...
	return x
}
```

#### gcStart(): 函数启动 GC

一旦通过一下任何一种情况, 都会启动 GC:

1. 垃圾回收系统会监控堆内存的使用情况。强制超时时间是2分钟。
2. 当堆内存使用达到一定阈值时，就会触发垃圾回收。阈值可以通过环境变量 `GOGC` 或 `debug.SetGCPercent` 设置。

**`gcStart` 方法的主要职责是初始化垃圾回收过程**

1. 创建多个后台 goroutine, 准备并发标记
2. stw暂停世界: 用户和刚刚创建的后台 goroutine全部暂停
3. 清扫上一轮垃圾回收未标记的垃圾
4. 开启写屏障
5. stw结束, 恢复所有用户和后台 goroutine 的执行, 并发标记开始

##### **完整的`gcStart` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 函数启动 GC。方法完成了从开始到进入并发标记阶段的关键操作，为后续的垃圾回收过程做好了准备
//
// 在某些情况下，此函数可能会不执行过渡就返回，例如当它在不可抢占的上下文中被调用或持有锁时。
func gcStart(trigger gcTrigger) {
	// 检查不可抢占或潜在不稳定的情况:
	// 由于此函数可能在 malloc 被调用时调用，而 malloc 可能在许多持有锁的库内部被调用，
	// 因此不要尝试在不可抢占或潜在不稳定的情况下启动 GC。

	// 获取内存锁
	mp := acquirem()
	//检查 goroutine: 使用 getg() 获取当前 goroutine。
	//检查是否持有锁: 检查是否持有锁 (mp.locks > 1) 或者是否不可抢占 (mp.preemptoff != "")。
	if gp := getg(); gp == mp.g0 || mp.locks > 1 || mp.preemptoff != "" {
		releasem(mp) // 释放内存锁
		return
	}
	// 释放内存锁
	releasem(mp)
	mp = nil

	// 并发清扫剩余区间

	// 循环清扫: 使用 for 循环和 sweepone 函数来帮助完成清扫阶段。
	// 检查过渡条件: 使用 trigger.test() 根据不同的触发条件来决定是否需要启动一个新的 GC 周期。
	for trigger.test() && sweepone() != ^uintptr(0) {
		sweep.nbgsweep++ // 增加清扫计数: 使用 sweep.nbgsweep++ 增加清扫计数。
	}

	// 执行 GC 初始化和清扫终止过渡

	semacquire(&work.startSema) // 获取启动信号量
	// 在过渡锁下重新检查过渡条件。
	if !trigger.test() {
		// 执行 GC 初始化和清扫终止过渡。
		semrelease(&work.startSema)
		return
	}

	// 在 gcstoptheworld 调试模式下，根据需要升级模式。
	// 我们在重新检查过渡条件之后这样做，以防止多个 goroutines 检测到堆触发条件并开始多个 STW GC。
	mode := gcBackgroundMode // 并发的垃圾回收和清扫
	if debug.gcstoptheworld == 1 {
		mode = gcForceMode // 立即执行停止世界的垃圾回收，清扫操作并发
	} else if debug.gcstoptheworld == 2 {
		mode = gcForceBlockMode // 立即执行停止世界的垃圾回收和清扫（由用户强制触发）
	}

	semacquire(&gcsema)    // 获取GC信号量
	semacquire(&worldsema) // 获取stw世界信号量

	// 为了统计，检查这次 GC 是否是由用户手动强制触发的。
	// 在 gcsema 下更新它以避免 gctrace 获取错误的值。
	work.userForced = trigger.kind == gcTriggerCycle

	// 如果启用了跟踪，则记录 GC 开始
	if traceEnabled() {
		traceGCStart()
	}

	// 检查所有 Ps 是否已完成延迟的 mcache 刷新。
	for _, p := range allp {
		if fg := p.mcache.flushGen.Load(); fg != mheap_.sweepgen {
			println("runtime: p", p.id, "flushGen", fg, "!= sweepgen", mheap_.sweepgen)
			throw("p mcache not flushed")
		}
	}

	gcBgMarkStartWorkers()                                // 创建多个后台 goroutine, 准备并发标记
	systemstack(gcResetMarkState)                         // 在标记阶段开始之前重置全局状态，并重置所有 G 的栈扫描状态。
	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs // 设置 STW 进程数
	if work.stwprocs > ncpu {
		// 这用于计算 STW 阶段的 CPU 时间，
		// 因此它不能超过 ncpu，即使 GOMAXPROCS 更大。
		work.stwprocs = ncpu
	}
	work.heap0 = gcController.heapLive.Load()
	work.pauseNS = 0
	work.mode = mode

	now := nanotime()
	work.tSweepTerm = now
	work.pauseStart = now
	systemstack(func() { stopTheWorldWithSema(stwGCSweepTerm) }) // stw 暂停世界
	// 在开始并发扫描之前完成清扫。
	systemstack(func() {
		finishsweep_m() // 函数确保所有 span 已经完成清扫, 被认为是垃圾的span被清扫
	})

	clearpools()                                           // 函数用于清除各种缓存和池，以减少内存占用并准备下一轮垃圾回收。
	work.cycles.Add(1)                                     // 增加周期数
	gcController.startCycle(now, int(gomaxprocs), trigger) // 协助和 worker 可以在我们开始世界的同时开始。
	gcCPULimiter.startGCTransition(true, now)              // 通知 CPU 限制器协助可以开始。

	// 如果不是并发的垃圾回收和清扫模式, 应该禁用用户 goroutine 的调度
	if mode != gcBackgroundMode {
		schedEnableUser(false) // 函数用于禁用用户 goroutine 的调度
	}

	// 进入并发标记阶段并启用写屏障。

	// 如果当前阶段是标记阶段 _GCmark 或标记终止阶段 _GCmarktermination ，则需要启用写屏障
	setGCPhase(_GCmark) // 设置 GC 并发标记阶段, 函数用于设置当前的垃圾回收阶段，并根据垃圾回收阶段调整写屏障的启用状态
	gcBgMarkPrepare()   // 准备后台标记, 这个条件被用来判断是否所有的标记工作都已经完成
    
    // 函数用于准备根扫描工作。这包括将全局变量、栈以及其他杂项放入队列中，并初始化扫描相关的状态。
    // go的垃圾回收并没有将跟对象标记为黑色, 而是收集到一个跟对象队列里面, 这个队列引用不会被垃圾回收。
    // 在根扫描阶段，根对象引用的对象会被标记为灰色，并加入到工作队列中
    // 根对象永远不会被垃圾回收，因为它们始终被认为是可达的
	gcMarkRootPrepare() 
	gcMarkTinyAllocs()  // 函数用于将所有活动的小块(小于 16 字节)分配（tiny allocation）标记为灰色。

	// 到此为止，所有 Ps 都已启用写屏障，从而维护了无白色到黑色的不变性。
	// 启用 mutator 协助以对快速分配的 mutator 施加反压。
	atomic.Store(&gcBlackenEnabled, 1)

	// 在 STW 模式下，我们可能会在 systemstack 返回后立即被阻止，因此确保我们不是可抢占的。

	// 获取内存锁
	mp = acquirem()

	// 并发标记。
	systemstack(func() {
		now = startTheWorldWithSema()                      // 函数用于恢复所有 goroutine 的执行。
		work.pauseNS += now - work.pauseStart              // 计算并累加暂停时间
		work.tMark = now                                   // 设置标记开始时间
		memstats.gcPauseDist.record(now - work.pauseStart) // 记录垃圾回收暂停时间分布

		// 计算清扫终止阶段消耗的 CPU 时间
		sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)
		work.cpuStats.gcPauseTime += sweepTermCpu // 累加垃圾回收暂停时间
		work.cpuStats.gcTotalTime += sweepTermCpu // 累加总的垃圾回收时间

		// 释放 CPU 限制器。
		gcCPULimiter.finishGCTransition(now)
	})

	// 在 STW 模式下，在 Gosched() 之前释放世界 sema，因为我们需要稍后重新获取它，
	// 但在这个 goroutine 可以再次运行之前，否则可能会自我死锁。
	semrelease(&worldsema) // 释放stw世界信号量

	// 释放内存锁
	releasem(mp)

	// 如果不是并发回收, 则让出 cpu
	if mode != gcBackgroundMode {
		Gosched() // 出 CPU 时间片，以便其他 goroutine 可以运行
	}

	semrelease(&work.startSema) // 释放启动信号量
}
```

##### **简单总结**:

```go
// 函数启动 GC。方法完成了从开始到进入并发标记阶段的关键操作，为后续的垃圾回收过程做好了准备
//
// 在某些情况下，此函数可能会不执行过渡就返回，例如当它在不可抢占的上下文中被调用或持有锁时。
func gcStart(trigger gcTrigger) {
	...
	gcBgMarkStartWorkers()                                // 创建多个后台 goroutine, 准备并发标记
	...
	systemstack(func() { stopTheWorldWithSema(stwGCSweepTerm) }) // stw 暂停世界
	// 在开始并发扫描之前完成清扫。
	systemstack(func() {
		finishsweep_m() // 函数确保所有 span 已经完成清扫, 被认为是垃圾的span被清扫
	})
	...
	// 如果当前阶段是标记阶段 _GCmark 或标记终止阶段 _GCmarktermination ，则需要启用写屏障
	setGCPhase(_GCmark) // 设置 GC 并发标记阶段, 函数用于设置当前的垃圾回收阶段，并根据垃圾回收阶段调整写屏障的启用状态
    
    // 函数用于准备根扫描工作。这包括将全局变量、栈以及其他杂项放入队列中，并初始化扫描相关的状态。
    // go的垃圾回收并没有将跟对象标记为黑色, 而是收集到一个跟对象队列里面, 这个队列引用不会被垃圾回收。
    // 在根扫描阶段，根对象引用的对象会被标记为灰色，并加入到工作队列中
    // 根对象永远不会被垃圾回收，因为它们始终被认为是可达的
	gcMarkRootPrepare() 
	...
	// 并发标记。
	systemstack(func() {
		now = startTheWorldWithSema()                      // 函数用于恢复所有 goroutine 的执行。
		...
	})
	...
}
```

1. `gcBgMarkStartWorkers()`: 创建多个后台 goroutine, 准备并发标记
2. `stopTheWorldWithSema`: stw暂停世界: 用户和刚刚创建的后台 goroutine全部暂停
3. `finishsweep_m`: 清扫上一轮垃圾回收未标记的垃圾
4. `setGCPhase(_GCmark)`: 开启写屏障
5. `startTheWorldWithSema`: stw结束, 恢复所有用户和后台 goroutine 的执行, 并发标记开始

此时就来到了 **并发标记阶段**, GC的 goroutine 会和我们用户的 goroutine 一起并发执行。

那什么时候标记完成呢?

```go
	gcBgMarkStartWorkers()                                // 创建多个后台 goroutine, 准备并发标记
```

也就是这个后台 goroutine执行的时候。

### 3. 并发标记

并发标记阶段, 由调度器 P, 触发 goroutine 的调度而激活后台 goroutine。

#### gcBgMarkStartWorkers(): 创建多个后台并发标记 goroutine

```go
// 函数准备后台标记工作 goroutine。创建足够数量的后台标记工作 goroutine。
// 这些 goroutine 将负责执行并发标记阶段的工作，以减少垃圾回收对应用程序性能的影响。
// 这些 goroutine 不会在标记阶段之前运行，但必须在工作未停止且从常规 G 栈上启动。
// 调用者必须持有 worldsema 信号量。
func gcBgMarkStartWorkers() {
	// 后台标记是由每个 P 上的 G 来执行的。确保每个 P 都有一个后台 GC G。
	//
	// 工作 G 在 GOMAXPROCS 减少时不会退出。如果 GOMAXPROCS 再次增加，
	// 我们可以重用旧的工作 G，无需创建新的工作 G。
	for gcBgMarkWorkerCount < gomaxprocs {
		// 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
		go gcBgMarkWorker() // 启动后台标记工作 goroutine,直到达到当前的 gomaxprocs 数量

		// 使用 notetsleepg 和 noteclear 来通知后台标记工作准备就绪
		// 这确保后台标记工作 G 在其所属的 P 下一个 findRunnableGCWorker 调用之前被加入池中
		notetsleepg(&work.bgMarkReady, -1)
		noteclear(&work.bgMarkReady)

		// 每启动一个后台标记工作 goroutine，就增加 gcBgMarkWorkerCount 的值
		gcBgMarkWorkerCount++
	}
}
```

#### gcBgMarkWorker(): 并发标记

##### **完整的`gcBgMarkWorker` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 函数是后台标记工作 goroutine 的主体。
// 它执行并发标记阶段的工作，以减少垃圾回收对应用程序性能的影响。
// 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
func gcBgMarkWorker() {
	// 获取当前 goroutine
	gp := getg()

	// 初始化后台标记工作 goroutine

	gp.m.preemptoff = "GC worker init" // 禁止抢占，防止在初始化后台标记工作 goroutine 时发生死锁。
	node := new(gcBgMarkWorkerNode)    // 创建后台标记工作节点
	gp.m.preemptoff = ""
	node.gp.set(gp)               // 设置节点中的 goroutine
	node.m.set(acquirem())        // 获取内存锁
	notewakeup(&work.bgMarkReady) // 通知后台标记工作准备就绪

	// 从这里开始，后台标记工作 goroutine 通常由 gcController.findRunnableGCWorker 协同调度。
	// 当执行 P 上的工作时，禁止抢占，因为我们正在处理 P 本地的工作缓冲区。
	// 当 preempt 标志设置时，这将使自己进入 _Gwaiting 状态，以等待 gcController.findRunnableGCWorker 在适当的时候唤醒。
	// 当启用抢占时（例如，在 gcMarkDone 中），这个工作 goroutine 可能会被抢占，并作为 _Grunnable G 从 runq 中调度。
	// 这是可以接受的；它最终会再次调用 gopark 以等待 gcController.findRunnableGCWorker 的进一步调度。

	// 等待被唤醒
	for {
		// 等待直到被 gcController.findRunnableGCWorker 唤醒。
		gopark(func(g *g, nodep unsafe.Pointer) bool {
			node := (*gcBgMarkWorkerNode)(nodep)

			if mp := node.m.ptr(); mp != nil {
				// 后台标记工作 goroutine 不再运行；释放 M。
				// 注意：一旦我们不再执行 P 本地标记工作，就可以安全地释放 M。
				// 但是，由于我们协同停止工作，当 gp.preempt 设置时，如果我们在循环中释放内存锁，
				// 接下来的 gopark 调用会立即抢占这个 G。这是安全的，但效率低下：G 必须重新调度，
				// 只是为了再次进入 gopark 并停车。因此，我们将释放内存锁的操作延迟到 G 停车之后。
				releasem(mp)
			}

			// 将这个 G 放回池中。
			gcBgMarkWorkerPool.push(&node.node)
			// 注意：此时，G 可能立即被重新调度并可能正在运行。
			return true
		}, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceBlockSystemGoroutine, 0)

		// 执行标记工作
		// 禁止在此处发生抢占，否则另一个 G 可能会看到 p.gcMarkWorkerMode。

		// 禁止抢占，以便我们可以使用 gcw。如果调度器想要抢占我们，
		// 我们将停止工作，释放 gcw，然后抢占。
		node.m.set(acquirem()) // 获取内存锁
		pp := gp.m.p.ptr()     // 获取当前 P

		// 检查标记是否启用
		if gcBlackenEnabled == 0 {
			println("worker mode", pp.gcMarkWorkerMode)
			throw("gcBgMarkWorker: blackening not enabled")
		}

		// 检查工作模式是否已设置
		if pp.gcMarkWorkerMode == gcMarkWorkerNotWorker {
			throw("gcBgMarkWorker: mode not set")
		}

		startTime := nanotime() // 获取开始时间
		pp.gcMarkWorkerStartTime = startTime
		var trackLimiterEvent bool
		if pp.gcMarkWorkerMode == gcMarkWorkerIdleMode {
			trackLimiterEvent = pp.limiterEvent.start(limiterEventIdleMarkWork, startTime)
		}

		decnwait := atomic.Xadd(&work.nwait, -1)
		if decnwait == work.nproc {
			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
			throw("work.nwait was > work.nproc")
		}

		// 使用 systemstack 根据工作模式执行不同的标记工作
		systemstack(func() {
			// 标记我们的 goroutine 为可抢占，以便其栈可以被扫描。
			// 这使得两个标记工作 goroutine 可以相互扫描（否则，它们会死锁）。
			// 我们必须不修改 G 栈上的任何内容。但是，标记工作 goroutine 禁用了栈缩小，所以从 G 栈读取是安全的。
			casGToWaiting(gp, _Grunning, waitReasonGCWorkerActive)

			// 使用 systemstack 根据工作模式执行不同的标记工作
			switch pp.gcMarkWorkerMode {
			default:
				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")

			// 专用模式下的标记工作
			case gcMarkWorkerDedicatedMode:
				gcDrain(&pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit) // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
				if gp.preempt {
					// 我们被抢占了。这是一个有用的信号，用于将所有内容从 runq 中踢出，
					// 以便它可以在其他地方运行。
					if drainQ, n := runqdrain(pp); n > 0 {
						lock(&sched.lock)
						globrunqputbatch(&drainQ, int32(n))
						unlock(&sched.lock)
					}
				}
				// 再次执行排水操作，这次不允许抢占。
				gcDrain(&pp.gcw, gcDrainFlushBgCredit) // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。

			// 分割模式下的标记工作
			case gcMarkWorkerFractionalMode:
				gcDrain(&pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit) // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。

			// 空闲模式下的标记工作
			case gcMarkWorkerIdleMode:
				gcDrain(&pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit) // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
			}

			// 恢复goroutine为可运行状态
			casgstatus(gp, _Gwaiting, _Grunning)
		})

		// 计算时间和标记我们为停止状态。
		now := nanotime()
		duration := now - startTime
		gcController.markWorkerStop(pp.gcMarkWorkerMode, duration)
		if trackLimiterEvent {
			pp.limiterEvent.stop(limiterEventIdleMarkWork, now)
		}
		if pp.gcMarkWorkerMode == gcMarkWorkerFractionalMode {
			atomic.Xaddint64(&pp.gcFractionalMarkTime, duration)
		}

		// 这是我们最后一个工作 goroutine 并且我们是否耗尽了工作？
		incnwait := atomic.Xadd(&work.nwait, +1)
		if incnwait > work.nproc {
			println("runtime: p.gcMarkWorkerMode=", pp.gcMarkWorkerMode,
				"work.nwait=", incnwait, "work.nproc=", work.nproc)
			throw("work.nwait > work.nproc")
		}

		// 我们必须清除工作模式，以避免将该模式归因于不同的（非工作）G 在 traceGoStart 中。
		pp.gcMarkWorkerMode = gcMarkWorkerNotWorker

		// 如果这个工作 goroutine 达到了后台标记完成点，向主 GC goroutine 发送信号。
		// incnwait == work.nproc 检查工作线程的等待计数是否等于当前的工作线程总数。
		//!gcMarkWorkAvailable(nil) 检查是否还有未完成的标记工作。
		// 这意味着如果所有可达的对象已经被标记，垃圾回收将进入标记终止阶段。
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
			releasem(node.m.ptr())
			node.m.set(nil)

			// 转换到标记终止阶段:
			// 调用 gcMarkDone() 函数将垃圾回收从标记阶段转换到标记终止阶段。
			// 这意味着如果所有可达的对象已经被标记，垃圾回收将进入下一个阶段。
			gcMarkDone() // 将垃圾回收从标记阶段转换到标记终止阶段，如果所有可达的对象已经被标记。
		}
	}
}
```

##### **简化方法**:

```go
// 函数是后台标记工作 goroutine 的主体。
// 它执行并发标记阶段的工作，以减少垃圾回收对应用程序性能的影响。
// 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
func gcBgMarkWorker() {
	...
	// 等待被唤醒
	for {
		// 等待直到被 gcController.findRunnableGCWorker 唤醒。
        ...
		// 执行标记工作
		// 使用 systemstack 根据工作模式执行不同的标记工作
		systemstack(func() {
			...
			// 使用 systemstack 根据工作模式执行不同的标记工作
			switch pp.gcMarkWorkerMode {
			default:
				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
			...
			// 空闲模式下的标记工作
			case gcMarkWorkerIdleMode:
                // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
				gcDrain(&pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit) 
			}
			...
		})


		// 如果这个工作 goroutine 达到了后台标记完成点，向主 GC goroutine 发送信号。
		// incnwait == work.nproc 检查工作线程的等待计数是否等于当前的工作线程总数。
		//!gcMarkWorkAvailable(nil) 检查是否还有未完成的标记工作。
		// 这意味着如果所有可达的对象已经被标记，垃圾回收将进入标记终止阶段。
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
			releasem(node.m.ptr())
			node.m.set(nil)

			// 转换到标记终止阶段:
			// 调用 gcMarkDone() 函数将垃圾回收从标记阶段转换到标记终止阶段。
			// 这意味着如果所有可达的对象已经被标记，垃圾回收将进入下一个阶段。
			gcMarkDone() // 将垃圾回收从标记阶段转换到标记终止阶段，如果所有可达的对象已经被标记。
		}
	}
}
```

这里我们着重关注`gcDrain()`方法: 扫描工作，即黑化灰色对象。

#### gcDrain(): 执行扫描工作，即黑化灰色对象

##### **完整的`gcBgMarkWorker` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 函数是在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
// 直到无法获得更多的工作。它可能在 GC 完成之前就返回；
// 调用者需要平衡来自其他处理器（P）的工作。
//
// 如果 flags & gcDrainUntilPreempt != 0，则 gcDrain 在 g.preempt 被设置时返回。
//
// 如果 flags & gcDrainIdle != 0，则 gcDrain 在有其他工作要做时返回。
//
// 如果 flags & gcDrainFractional != 0，则 gcDrain 在 pollFractionalWorkerExit() 返回 true 时自我抢占。
// 这意味着 gcDrainNoBlock。
//
// 如果 flags & gcDrainFlushBgCredit != 0，则 gcDrain 每隔 gcCreditSlack 单位的扫描工作就将扫描工作信用
// 冲刷到 gcController.bgScanCredit。
//
// gcDrain 总是在有待定的停止世界（STW）操作时返回。
//
//go:nowritebarrier
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
	// 如果写屏障不需要，则抛出错误，因为这表明垃圾回收阶段不正确
	if !writeBarrier.needed {
		throw("gcDrain phase incorrect")
	}

	gp := getg().m.curg                              // 获取当前正在运行的 goroutine。
	preemptible := flags&gcDrainUntilPreempt != 0    // 如果设置了 gcDrainUntilPreempt 标志，则在当前 goroutine 被抢占时返回。
	flushBgCredit := flags&gcDrainFlushBgCredit != 0 // 如果设置了 gcDrainFlushBgCredit 标志，则定期将扫描工作信用冲刷到全局账户。
	idle := flags&gcDrainIdle != 0                   // 如果设置了 gcDrainIdle 标志，则在有其他工作可以做时返回。

	initScanWork := gcw.heapScanWork // 记录初始扫描工作量。

	// checkWork 表示在执行下一次自我抢占检查之前的扫描工作量。
	// 初始值设为一个大数，表示首次检查将在执行大量工作之后。
	checkWork := int64(1<<63 - 1) // 初始值为最大整数值减一。
	var check func() bool         // 声明检查函数。

	// 如果设置了 gcDrainIdle 或 gcDrainFractional 标志，则设置检查工作量和检查函数。
	if flags&(gcDrainIdle|gcDrainFractional) != 0 {
		// 将初始扫描工作量加上阈值作为新的检查工作量。
		checkWork = initScanWork + drainCheckThreshold
		// 根据标志设置检查函数。
		if idle {
			// 如果设置了 gcDrainIdle 标志，则使用 pollWork 函数检查是否有其他工作可以做。
			check = pollWork
		} else if flags&gcDrainFractional != 0 {
			// 如果设置了 gcDrainFractional 标志，则使用 pollFractionalWorkerExit 函数检查是否应自我抢占。
			check = pollFractionalWorkerExit
		}
	}

	// 检查是否还有未完成的根对象标记任务:
	// 检查 work.markrootNext 是否小于 work.markrootJobs。
	// work.markrootNext 表示已标记的根对象数量。
	// work.markrootJobs 表示需要标记的根对象总数。
	if work.markrootNext < work.markrootJobs {
		// 循环执行标记任务:
		// 进入循环，直到满足停止条件：
		// gp.preempt 为真，表示 goroutine 可能会被抢占。
		// preemptible 为真，表示允许抢占。
		// sched.gcwaiting.Load() 返回真，表示有其他 goroutine 正在等待 GC 完成。
		for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
			// 原子增加 work.markrootNext 并获取下一个任务的索引。
			job := atomic.Xadd(&work.markrootNext, +1) - 1
			// 如果所有根集标记任务已完成，则跳出循环。
			if job >= work.markrootJobs {
				break
			}

			markroot(gcw, job, flushBgCredit) // 扫描第 job 个根对象, 将根对象引用的对象标记为灰色

			// 如果设置了检查函数并且检查函数返回 true，则提前结束循环。
			if check != nil && check() {
				goto done
			}
		}
	}

	// 循环处理堆中的对象，直到没有可达的对象为止
	// gp.preempt 表示是否需要抢占
	// preemptible 表示是否可以被抢占
	// sched.gcwaiting.Load() 表示是否有其他协程在等待垃圾回收完成
	for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
		// 如果 work.full == 0，则调用 gcw.balance() 来平衡工作负载
		if work.full == 0 {
			gcw.balance()
		}

		b := gcw.tryGetFast() // 尝试快速获取一个对象 b。
		if b == 0 {
			b = gcw.tryGet() // 如果快速获取失败，则尝试正常获取。
			if b == 0 {
				// 将当前 P 的写屏障缓冲区刷新到垃圾回收的工作缓冲区
				wbBufFlush() // 如果获取失败，刷新写屏障缓冲区并再次尝试获取。
				b = gcw.tryGet()
			}
		}
		if b == 0 {
			break
		}

		// gcw工作队列中的对象随着扫描过程的变化而变化。
		// 通过循环和扫描过程，最终标记所有可达对象。
		scanobject(b, gcw) // 扫描对象, 即黑化灰色对象, 并将引用的对象标记为灰色, 加入到 gcw 的工作队列中

		// 如果本地积累的扫描工作信用足够多，则将其冲刷到全局账户，
		// 以便协程协助可以使用它。
		if gcw.heapScanWork >= gcCreditSlack {
			gcController.heapScanWork.Add(gcw.heapScanWork) // 将本地扫描工作信用添加到全局账户。
			if flushBgCredit {
				gcFlushBgCredit(gcw.heapScanWork - initScanWork) // 冲刷扫描工作信用到全局账户。
				initScanWork = 0
			}
			checkWork -= gcw.heapScanWork
			gcw.heapScanWork = 0

			if checkWork <= 0 {
				checkWork += drainCheckThreshold // 重置检查工作量。
				// 如果检查函数返回 true，则跳出循环。
				if check != nil && check() {
					break
				}
			}
		}
	}

done:
	// 冲刷剩余的扫描工作信用。
	if gcw.heapScanWork > 0 {
		gcController.heapScanWork.Add(gcw.heapScanWork)
		if flushBgCredit {
			gcFlushBgCredit(gcw.heapScanWork - initScanWork)
		}
		gcw.heapScanWork = 0
	}
}
```

##### **简化方法**:

```go
// 函数是在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
// 直到无法获得更多的工作。它可能在 GC 完成之前就返回；
// 调用者需要平衡来自其他处理器（P）的工作。
//
// 如果 flags & gcDrainUntilPreempt != 0，则 gcDrain 在 g.preempt 被设置时返回。
//
// 如果 flags & gcDrainIdle != 0，则 gcDrain 在有其他工作要做时返回。
//
// 如果 flags & gcDrainFractional != 0，则 gcDrain 在 pollFractionalWorkerExit() 返回 true 时自我抢占。
// 这意味着 gcDrainNoBlock。
//
// 如果 flags & gcDrainFlushBgCredit != 0，则 gcDrain 每隔 gcCreditSlack 单位的扫描工作就将扫描工作信用
// 冲刷到 gcController.bgScanCredit。
//
// gcDrain 总是在有待定的停止世界（STW）操作时返回。
//
//go:nowritebarrier
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
	// 如果写屏障不需要，则抛出错误，因为这表明垃圾回收阶段不正确
	if !writeBarrier.needed {
		throw("gcDrain phase incorrect")
	}
	...

	// 检查是否还有未完成的根对象标记任务:
	// 检查 work.markrootNext 是否小于 work.markrootJobs。
	// work.markrootNext 表示已标记的根对象数量。
	// work.markrootJobs 表示需要标记的根对象总数。
	if work.markrootNext < work.markrootJobs {
		// 循环执行标记任务:
		// 进入循环，直到满足停止条件：
		// gp.preempt 为真，表示 goroutine 可能会被抢占。
		// preemptible 为真，表示允许抢占。
		// sched.gcwaiting.Load() 返回真，表示有其他 goroutine 正在等待 GC 完成。
		for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
			// 原子增加 work.markrootNext 并获取下一个任务的索引。
			job := atomic.Xadd(&work.markrootNext, +1) - 1
			// 如果所有根集标记任务已完成，则跳出循环。
			if job >= work.markrootJobs {
				break
			}

			markroot(gcw, job, flushBgCredit) // 扫描第 job 个根对象, 将根对象引用的对象标记为灰色
			...
		}
	}

	// 循环处理堆中的对象，直到没有可达的对象为止
	// gp.preempt 表示是否需要抢占
	// preemptible 表示是否可以被抢占
	// sched.gcwaiting.Load() 表示是否有其他协程在等待垃圾回收完成
	for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
		...
		b := gcw.tryGetFast() // 尝试快速获取一个对象 b。
		if b == 0 {
			b = gcw.tryGet() // 如果快速获取失败，则尝试正常获取。
			if b == 0 {
				// 将当前 P 的写屏障缓冲区刷新到垃圾回收的工作缓冲区
				wbBufFlush() // 如果获取失败，刷新写屏障缓冲区并再次尝试获取。
				b = gcw.tryGet()
			}
		}
		if b == 0 {
			break
		}

		// gcw工作队列中的对象随着扫描过程的变化而变化。
		// 通过循环和扫描过程，最终标记所有可达对象。
		scanobject(b, gcw) // 扫描对象, 即黑化灰色对象, 并将引用的对象标记为灰色, 加入到 gcw 的工作队列中
		...
	}
	...
}
```

这里有2个主要的方法:

- `markroot`: 扫描第 job 个根对象, 将根对象引用的对象标记为灰色
- `scanobject`: 扫描对象, 即黑化灰色对象

#### markroot(): 扫描第 job 个根对象, 将根对象引用的对象标记为灰色

这里我们再次提醒, 三色标记法, 再第一次`stw`暂停世界的时候会标记所有跟对象为黑色。

但是实际上go的垃圾回收是没有将跟对象标记为黑色的步骤的:

```go
// 函数启动 GC。方法完成了从开始到进入并发标记阶段的关键操作，为后续的垃圾回收过程做好了准备
//
// 在某些情况下，此函数可能会不执行过渡就返回，例如当它在不可抢占的上下文中被调用或持有锁时。
func gcStart(trigger gcTrigger) {
    ...
	// 函数用于准备根扫描工作。这包括将全局变量、栈以及其他杂项放入队列中，并初始化扫描相关的状态。
	// go的垃圾回收并没有将跟对象标记为黑色, 而是收集到一个跟对象队列里面, 这个队列引用不会被垃圾回收。
	// 在根扫描阶段，根对象引用的对象会被标记为灰色，并加入到工作队列中
	// 根对象永远不会被垃圾回收，因为它们始终被认为是可达的
	gcMarkRootPrepare() // 函数用于准备根扫描工作, 这包括将全局变量、栈以及其他杂项放入队列中，并初始化扫描相关的状态。
	...
}
```

go的垃圾回收并没有将跟对象标记为黑色, 而是收集到一个跟对象队列里面, 这个队列引用不会被垃圾回收。

然后再并发标记的过程中, 会遍历根对象引用的对象会被标记为灰色，并加入到工作队列中

- 根对象在创建时就已经被确定为可达的。
- 根对象的存储位置是固定的，可以通过这些位置找到根对象。

##### **完整的`markroot` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 扫描第 i 个根对象, 将根对象引用的对象标记为灰色
//
// 必须禁用抢占（因为这使用了 gcWork）。
//
// 返回操作产生的 GC 工作量。
// 如果 flushBgCredit 为 true，则还会将该工作量刷新到后台信用池。
//
// 在此处 nowritebarrier 仅是一个建议性的声明。
//
// - `gcw` 是一个指向 `gcWork` 结构的指针，用于管理垃圾回收工作的队列。
// - `i` 是一个 `uint32` 类型的整数，表示当前扫描的根对象的索引。
// - `flushBgCredit` 是一个布尔值，指示是否应该将产生的 GC 工作量刷新到后台信用池。
//
//go:nowritebarrier
func markroot(gcw *gcWork, i uint32, flushBgCredit bool) int64 {
	// 注意：如果在此处添加一个 case，请同时更新 heapdump.go:dumproots。
	var workDone int64
	var workCounter *atomic.Int64
	switch {
	// 处理基础数据段（.data 到 .edata 之间的数据）: 已初始化的全局变量和静态变量
	case work.baseData <= i && i < work.baseBSS:
		workCounter = &gcController.globalsScanWork
		for _, datap := range activeModules() {
			workDone += markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-work.baseData))
		}

	// 处理基础 BSS 段（.bss 到 .ebss 之间的数据）: 未初始化的全局变量和静态变量
	case work.baseBSS <= i && i < work.baseSpans:
		workCounter = &gcController.globalsScanWork
		for _, datap := range activeModules() {
			workDone += markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-work.baseBSS))
		}

	// 处理固定根 finalizer
	// 在 Go 语言中，finalizer 是一个指定的函数，当一个对象即将被垃圾回收器回收时，会调用该函数来执行一些清理操作，比如关闭文件、释放资源等。
	// 这些对象的 finalizer 需要在垃圾回收过程中被特殊处理，确保在清理操作时正常工作
	case i == fixedRootFinalizers:
		for fb := allfin; fb != nil; fb = fb.alllink {
			cnt := uintptr(atomic.Load(&fb.cnt))
			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw, nil)
		}

	// 处理固定根 free G stacks
	// 在 Go 中，每个 Goroutine 都有一个对应的栈空间，用于执行函数。当 Goroutine 不再活跃时，其栈空间可能需要被释放以节省资源。
	// 在垃圾回收过程中，需要特殊处理这些对象，确保正确释放不再使用的 Goroutine 栈。
	case i == fixedRootFreeGStacks:
		// 切换到系统栈以便调用 stackfree。
		systemstack(markrootFreeGStacks)

	// 处理基础 Span 段（.span 到 .espan 之间的数据）: 分配 Span 的数据结构
	// 在 Go 内存管理中，Span 是用于分配和管理内存的数据结构，通常代表一段连续的内存区域。
	// .span 到 .espan 之间的数据表示的是用于表示内存分配 Span 的相关数据。
	// 在垃圾回收过程中，这些数据结构需要被标记，以确保垃圾回收器正确地跟踪内存的使用情况，对未使用的内存进行回收。
	case work.baseSpans <= i && i < work.baseStacks:
		// mark mspan.specials
		markrootSpans(gcw, int(i-work.baseSpans))

	// 其余情况为扫描 goroutine 堆栈
	default:
		// stackScanWork 是本周期内执行的栈扫描工作的总量。
		workCounter = &gcController.stackScanWork
		if i < work.baseStacks || work.baseEnd <= i {
			printlock()
			print("runtime: markroot index ", i, " not in stack roots range [", work.baseStacks, ", ", work.baseEnd, ")\n")
			throw("markroot: bad index")
		}

		// 获取要扫描的 goroutine
		gp := work.stackRoots[i-work.baseStacks]

		// 如果 goroutine 处于等待或系统调用状态，记录等待时间。
		status := readgstatus(gp) // 我们不在扫描状态
		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
			gp.waitsince = work.tstart
		}

		// 垃圾回收器能够有效地扫描 goroutine 的堆栈
		systemstack(func() {
			// 获取当前 goroutine (userG)
			userG := getg().m.curg

			// 判断是否为自我扫描：selfScan 为 true 当前 goroutine 正在扫描自己，并且其状态为 _Grunning
			selfScan := gp == userG && readgstatus(userG) == _Grunning
			// 如果是自我扫描，将当前 goroutine (userG) 的状态设置为 _Gwaiting，以防止自我死锁
			if selfScan {
				casGToWaiting(userG, _Grunning, waitReasonGarbageCollectionScan)
			}

			// 使用 suspendG 函数暂停 gp，以便扫描其堆栈, 阻塞（并自旋）直到 gp 停止。
			stopped := suspendG(gp)
			// 如果 gp 已经死亡，标记为扫描完成并返回。
			if stopped.dead {
				gp.gcscandone = true // 表示 g 已扫描栈；受 _Gscan 状态位保护。
				return
			}
			// 如果 goroutine 已经被扫描过，则抛出异常
			if gp.gcscandone {
				throw("g already scanned")
			}

			workDone += scanstack(gp, gcw) // 对根对象所在的内存块进行扫描，并将根对象引用的对象标记为灰色
			gp.gcscandone = true           // 表示 g 已扫描栈；受 _Gscan 状态位保护。

			// 完成扫描后，使用 resumeG 函数恢复 goroutine 的执行
			resumeG(stopped)

			// 如果是自我扫描，恢复到 _Grunning 状态
			if selfScan {
				casgstatus(userG, _Gwaiting, _Grunning)
			}
		})
	}

	// 如果 workCounter 不为 nil 并且 workDone 不为零，则添加工作量到 workCounter 中。
	// 如果 flushBgCredit 为 true，则将工作量刷新到后台信用池。
	// 根据扫描的根对象类型，函数可能会更新不同的工作量计数器
	if workCounter != nil && workDone != 0 {
		workCounter.Add(workDone)
		if flushBgCredit {
			gcFlushBgCredit(workDone)
		}
	}
	return workDone
}
```

##### **简化方法**:

```go
// 扫描第 i 个根对象, 将根对象引用的对象标记为灰色
//
// 必须禁用抢占（因为这使用了 gcWork）。
//
// 返回操作产生的 GC 工作量。
// 如果 flushBgCredit 为 true，则还会将该工作量刷新到后台信用池。
//
// 在此处 nowritebarrier 仅是一个建议性的声明。
//
// - `gcw` 是一个指向 `gcWork` 结构的指针，用于管理垃圾回收工作的队列。
// - `i` 是一个 `uint32` 类型的整数，表示当前扫描的根对象的索引。
// - `flushBgCredit` 是一个布尔值，指示是否应该将产生的 GC 工作量刷新到后台信用池。
//
//go:nowritebarrier
func markroot(gcw *gcWork, i uint32, flushBgCredit bool) int64 {
	switch {
	...
	// 其余情况为扫描 goroutine 堆栈
	default:
        ...
		// 获取要扫描的 goroutine
		gp := work.stackRoots[i-work.baseStacks]
		...
		// 垃圾回收器能够有效地扫描 goroutine 的堆栈
		systemstack(func() {
			// 获取当前 goroutine (userG)
			userG := getg().m.curg

			// 判断是否为自我扫描：selfScan 为 true 当前 goroutine 正在扫描自己，并且其状态为 _Grunning
			selfScan := gp == userG && readgstatus(userG) == _Grunning
			// 如果是自我扫描，将当前 goroutine (userG) 的状态设置为 _Gwaiting，以防止自我死锁
			if selfScan {
				casGToWaiting(userG, _Grunning, waitReasonGarbageCollectionScan)
			}

			// 使用 suspendG 函数暂停 gp，以便扫描其堆栈, 阻塞（并自旋）直到 gp 停止。
			stopped := suspendG(gp)
			// 如果 gp 已经死亡，标记为扫描完成并返回。
			if stopped.dead {
				gp.gcscandone = true // 表示 g 已扫描栈；受 _Gscan 状态位保护。
				return
			}
			// 如果 goroutine 已经被扫描过，则抛出异常
			if gp.gcscandone {
				throw("g already scanned")
			}

			workDone += scanstack(gp, gcw) // 对根对象所在的内存块进行扫描，并将根对象引用的对象标记为灰色
			gp.gcscandone = true           // 表示 g 已扫描栈；受 _Gscan 状态位保护。

			// 完成扫描后，使用 resumeG 函数恢复 goroutine 的执行
			resumeG(stopped)

			// 如果是自我扫描，恢复到 _Grunning 状态
			if selfScan {
				casgstatus(userG, _Gwaiting, _Grunning)
			}
		})
	}
	...
}
```

#### scanobject(): 扫描根对象内存区域, 即黑化灰色对象

调用完成`markroot`标记跟对象的引用对象后, 就要开始递归的扫描根可达对象的链路了

回头看`gcDrain`:执行扫描工作，即黑化灰色对象:

**接下来就是循环处理堆中的对象，直到没有可达的对象为止**

```go
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
	...
		for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
			...
			markroot(gcw, job, flushBgCredit) // 扫描第 job 个根对象, 将根对象引用的对象标记为灰色
            ...
        }
	...
	// 循环处理堆中的对象，直到没有可达的对象为止
	// gp.preempt 表示是否需要抢占
	// preemptible 表示是否可以被抢占
	// sched.gcwaiting.Load() 表示是否有其他协程在等待垃圾回收完成
	for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
		...
		// gcw工作队列中的对象随着扫描过程的变化而变化。
		// 通过循环和扫描过程，最终标记所有可达对象。
		scanobject(b, gcw) // 扫描对象, 即黑化灰色对象, 并将引用的对象标记为灰色, 加入到 gcw 的工作队列中
		...
	}
	...
}
```

##### **完整的`scanobject` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 扫描从 b 开始的对象，遍历将下一个子对象标记为灰色, 并将指针添加到 gcw 中。
// b 必须指向堆对象或 oblet 的开始位置。
// scanobject 会查询 GC 位图以获取指针掩码，并查询 span 以获取对象的大小。
//
// - b 是一个 uintptr 类型的指针，表示要扫描的对象的起始地址。
// - gcw 是一个指向 gcWork 结构的指针，用于管理垃圾回收工作的队列。
//
//go:nowritebarrier
func scanobject(b uintptr, gcw *gcWork) {
	// 预取对象，以便在扫描之前进行预加载。
	//
	// 这将重叠获取对象的开头与扫描对象之前的初始设置。
	sys.Prefetch(b)

	// 查找 b 的位图信息和 b 处对象的大小。
	//
	// b 要么是对象的开头，这时就是要扫描的对象的大小；
	// 要么是指向 oblet 的位置，这时我们将在下面计算要扫描的大小。
	s := spanOfUnchecked(b)
	n := s.elemsize
	if n == 0 {
		throw("scanobject n == 0")
	}
	if s.spanclass.noscan() {
		// 从技术上讲这是可以接受的，但如果 noscan 对象到达这里，效率较低。
		throw("scanobject of a noscan object")
	}

	// 如果对象大小超过 maxObletBytes，则将其拆分成 oblets。
	// 如果 b 是对象的起始位置，则将其他 oblets 加入队列以稍后扫描。
	// 计算 oblet 的大小，确保不超过 maxObletBytes。
	if n > maxObletBytes {
		// 大对象。为了更好的并行性和更低的延迟，将其拆分成 oblets。
		if b == s.base() {
			// 将其他 oblets 加入队列以稍后扫描。
			// 有些 oblets 可能在 b 的标量尾部，但这些 oblets 将被标记为 "不再有指针"，
			// 因此当我们去扫描它们时会立即退出。
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
				if !gcw.putFast(oblet) {
					gcw.put(oblet)
				}
			}
		}

		// 计算 oblet 的大小。因为这个对象一定是大对象，所以 s.base() 是对象的开始位置。
		n = s.base() + s.elemsize - b
		if n > maxObletBytes {
			n = maxObletBytes
		}
	}

	hbits := heapBitsForAddr(b, n)

	// 循环遍历对象中的指针。调用 greyobject 将其标记为灰色
	// 因为一个对象可以被多个对象引用, 所以这里需要遍历
	var scanSize uintptr
	for {
		var addr uintptr
		// 使用 hbits.nextFast 和 hbits.next 获取下一个可能的指针地址 addr。
		if hbits, addr = hbits.nextFast(); addr == 0 {
			if hbits, addr = hbits.next(); addr == 0 {
				break
			}
		}

		// 更新 scanSize 以跟踪最远的指针位置。
		// 记录找到的最远指针的位置，以便更新 heapScanWork。
		// TODO: 是否有更好的指标，现在我们能非常有效地跳过标量部分？
		scanSize = addr - b + goarch.PtrSize

		// 提取指针 obj。
		// 下面的工作在 scanblock 和上面的部分都有重复。
		// 如果你在这里做出更改，请也在那里做出相应的更改。
		obj := *(*uintptr)(unsafe.Pointer(addr))

		// 如果 obj 不是零且不在当前对象内，则测试 obj 是否指向 Go 堆中的对象。
		if obj != 0 && obj-b >= n {
			if obj, span, objIndex := findObject(obj, b, addr-b); obj != 0 {
				greyobject(obj, b, addr-b, span, gcw, objIndex) // 如果 obj 指向堆中的对象，则调用 greyobject 将其标记为灰色
			}
		}
	}

	// 标记为黑色
	gcw.bytesMarked += uint64(n) // 标记为黑色
	gcw.heapScanWork += int64(scanSize)
}
```

##### **简化方法**:

```go
// 扫描从 b 开始的对象，遍历将下一个子对象标记为灰色, 并将指针添加到 gcw 中。
// b 必须指向堆对象或 oblet 的开始位置。
// scanobject 会查询 GC 位图以获取指针掩码，并查询 span 以获取对象的大小。
//
// - b 是一个 uintptr 类型的指针，表示要扫描的对象的起始地址。
// - gcw 是一个指向 gcWork 结构的指针，用于管理垃圾回收工作的队列。
//
//go:nowritebarrier
func scanobject(b uintptr, gcw *gcWork) {
	...
	// 循环遍历对象中的指针。调用 greyobject 将其标记为灰色
	// 因为一个对象可以被多个对象引用, 所以这里需要遍历
	var scanSize uintptr
	for {
		var addr uintptr
		// 使用 hbits.nextFast 和 hbits.next 获取下一个可能的指针地址 addr。
		if hbits, addr = hbits.nextFast(); addr == 0 {
			if hbits, addr = hbits.next(); addr == 0 {
				break
			}
		}
		...
		// 如果 obj 不是零且不在当前对象内，则测试 obj 是否指向 Go 堆中的对象。
		if obj != 0 && obj-b >= n {
			if obj, span, objIndex := findObject(obj, b, addr-b); obj != 0 {
				greyobject(obj, b, addr-b, span, gcw, objIndex) // 如果 obj 指向堆中的对象，则调用 greyobject 将其标记为灰色
			}
		}
	}

	// 标记为黑色
	gcw.bytesMarked += uint64(n) // 标记为黑色
	gcw.heapScanWork += int64(scanSize)
}
```

这里有一个重要的点: **将扫描过的对象标记为黑色, 将引用这个对象的对象标记为灰色**

将引用这个对象的对象标记为灰色很好理解, 但是将扫描过的对象标记为黑色源码中并不是直接标记

```go
gcw.bytesMarked += uint64(n) // 标记为黑色
```

他只是将扫描过的对象的字节大小追加到`bytesMarked`遍历中, **并不是传统三色标记法中, 将这个扫描过的对象标记为黑色**。

- 在扫描过程中，对象会被标记，并且它们的大小会被累加到 `gcw.bytesMarked` 变量中，表示在这个 `gcWork` 上标记（黑化）的字节数。
- 对象被标记后，并不会明确地变为黑色。
- 相反，通过更新 `gcw.bytesMarked` 来追踪标记过程中的进度。
- **实际上go的垃圾回收从来就没有标记黑色的实际动作, 三色标记发是一种思想, go的垃圾回收并没有真正的标记三种颜色**
    - 跟对象在创建的时候就已经被安排到特点的内存区域, 一定是可达的, 不会被垃圾回收
    - 所有被gcw工作队列中的对象是扫描后根可达的, 不会被垃圾回收
    - 剩余的其他对象, 既不属于跟对象的内存区域, 也没有被加入gcw工作队列, 那么这些对象就会被垃圾回收

#### greyobject(): 标记一个span为灰色, 不可被垃圾回收

```go
// 将对象标记为灰色，并将其加入 gcw 的工作队列中。
// - obj 是一个 uintptr 类型的指针，表示要标记的对象的起始地址。
// - base 是一个 uintptr 类型的指针，表示对象所在内存块的基地址，仅用于调试。
// - off 是一个 uintptr 类型的整数，表示对象相对于 base 的偏移量，仅用于调试。
// - span 是一个指向 mspan 结构的指针，表示对象所在的 span。
// - gcw 是一个指向 gcWork 结构的指针，用于管理垃圾回收工作的队列。
// - objIndex 是一个 uintptr 类型的整数，表示对象在 span 中的索引。
//
// 请参考 wbBufFlush1，它部分复制了此函数的逻辑。
//
//go:nowritebarrierrec
func greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr) {
	// obj 应该是分配的起始位置，因此必须至少是指针对齐的。
	if obj&(goarch.PtrSize-1) != 0 {
		throw("greyobject: obj not pointer-aligned")
	}
	mbits := span.markBitsForIndex(objIndex)

	if useCheckmark {
		if setCheckmark(obj, base, off, mbits) {
			// 已经标记过。
			return
		}
	} else {
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
			print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n")
			gcDumpObject("base", base, off)
			gcDumpObject("obj", obj, ^uintptr(0))
			getg().m.traceback = 2
			throw("marking free object")
		}

		// 如果已经标记，就没有事情要做。
		if mbits.isMarked() {
			return
		}
		mbits.setMarked() // 标记为灰色

		// 标记 span。
		arena, pageIdx, pageMask := pageIndexOf(span.base())
		if arena.pageMarks[pageIdx]&pageMask == 0 {
			atomic.Or8(&arena.pageMarks[pageIdx], pageMask)
		}

		// 如果这是一个不需要扫描的对象，快速将其标记为黑色，
		// 而不是将其标记为灰色。
		if span.spanclass.noscan() {
			gcw.bytesMarked += uint64(span.elemsize)
			return
		}
	}

	// 我们正在将 obj 添加到 P 的本地工作队列中，因此很可能
	// 这个对象很快就会被同一个 P 处理。
	// 即使工作队列被刷新，对于具有包容共享缓存的平台而言，
	// 仍然可能会有一些好处。
	sys.Prefetch(obj)
	// 将 obj 排队以供扫描。
	if !gcw.putFast(obj) {
		gcw.put(obj)
	}
}
```

- 一个 `span` 可以包含多个对象。
- 一旦 `span` 中的任何一个对象被标记为可达（灰色），那么整个 `span` 将被视为可达，并且不会在这个垃圾回收周期中被回收。
- 如果 `span` 中的所有对象都是不可达的，那么整个 `span` 将被视为不可达，并且可以被垃圾回收器回收。

### 4. 标记终止(最终标记)

已经遍历完成所有可达对象, 并且都加入到了gcw工作队列后, 回到`gcBgMarkWorker`: 并发标记步骤

下面将会来到标记终止阶段, 那么终止

```go
// 函数是后台标记工作 goroutine 的主体。
// 它执行并发标记阶段的工作，以减少垃圾回收对应用程序性能的影响。
// 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
func gcBgMarkWorker() {
	...
                // 在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
				gcDrain(&pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit) 
	...


    // 如果这个工作 goroutine 达到了后台标记完成点，向主 GC goroutine 发送信号。
    // incnwait == work.nproc 检查工作线程的等待计数是否等于当前的工作线程总数。
    //!gcMarkWorkAvailable(nil) 检查是否还有未完成的标记工作。
    if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
        releasem(node.m.ptr())
        node.m.set(nil)

        // 转换到标记终止阶段:
        // 调用 gcMarkDone() 函数将垃圾回收从标记阶段转换到标记终止阶段。
        // 这意味着如果所有可达的对象已经被标记，垃圾回收将进入下一个阶段。
        gcMarkDone() // 将垃圾回收从标记阶段转换到标记终止阶段，如果所有可达的对象已经被标记。
    }
}
```

#### gcMarkWorkAvailable(): 检测并发标记是否完成

```go
// 用于报告在给定的 P 上执行标记工作是否可能有用。
// 如果 p 为 nil，则仅检查全局的工作源。
//
// - p 是一个指向 p 结构体的指针，表示要检查的 P。
//
// 返回值是一个布尔值，表示是否有可用的工作。
func gcMarkWorkAvailable(p *p) bool {
	...
	// 如果全局工作队列不为空，则表明有可用的工作。
	if !work.full.empty() {
		return true // 全局工作可用
	}
	...
	// 如果以上条件都不满足，则表明没有可用的工作
	return false
}
```

那么这个`work.full`是什么时候为空的呢?

`gcDrain`: 发标记阶段有一个获取对象的逻辑

```go
// 函数是在并发标记阶段执行的, 主要目的是执行扫描工作，即黑化灰色对象。
// 直到无法获得更多的工作。它可能在 GC 完成之前就返回；
// 调用者需要平衡来自其他处理器（P）的工作。
//
// 如果 flags & gcDrainUntilPreempt != 0，则 gcDrain 在 g.preempt 被设置时返回。
//
// 如果 flags & gcDrainIdle != 0，则 gcDrain 在有其他工作要做时返回。
//
// 如果 flags & gcDrainFractional != 0，则 gcDrain 在 pollFractionalWorkerExit() 返回 true 时自我抢占。
// 这意味着 gcDrainNoBlock。
//
// 如果 flags & gcDrainFlushBgCredit != 0，则 gcDrain 每隔 gcCreditSlack 单位的扫描工作就将扫描工作信用
// 冲刷到 gcController.bgScanCredit。
//
// gcDrain 总是在有待定的停止世界（STW）操作时返回。
//
//go:nowritebarrier
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
	...
	// 循环处理堆中的对象，直到没有可达的对象为止
	// gp.preempt 表示是否需要抢占
	// preemptible 表示是否可以被抢占
	// sched.gcwaiting.Load() 表示是否有其他协程在等待垃圾回收完成
	for !(gp.preempt && (preemptible || sched.gcwaiting.Load())) {
		...
		b := gcw.tryGetFast() // 尝试快速获取一个对象 b。
		if b == 0 {
			b = gcw.tryGet() // 如果快速获取失败，则尝试正常获取。
			if b == 0 {
				// 将当前 P 的写屏障缓冲区刷新到垃圾回收的工作缓冲区
				wbBufFlush() // 如果获取失败，刷新写屏障缓冲区并再次尝试获取。
				b = gcw.tryGet()
			}
		}
		if b == 0 {
			break
		}

		// gcw工作队列中的对象随着扫描过程的变化而变化。
		// 通过循环和扫描过程，最终标记所有可达对象。
		scanobject(b, gcw) // 扫描对象, 即黑化灰色对象, 并将引用的对象标记为灰色, 加入到 gcw 的工作队列中
		...
	}
	...
}
```

```go
		b := gcw.tryGetFast() // 尝试快速获取一个对象 b。
		if b == 0 {
			b = gcw.tryGet() // 如果快速获取失败，则尝试正常获取。
			if b == 0 {
				// 将当前 P 的写屏障缓冲区刷新到垃圾回收的工作缓冲区
				wbBufFlush() // 如果获取失败，刷新写屏障缓冲区并再次尝试获取。
				b = gcw.tryGet()
			}
		}
```

```go
// tryGet 从垃圾回收器的工作队列中获取一个指针以供追踪。
//
// 如果当前的 gcWork 或全局队列中没有剩余的指针，则 tryGet 返回 0。
// 注意，即使返回 0，也可能存在其他 gcWork 实例或其他缓存中仍有待处理的指针。
//
//go:nowritebarrierrec
func (w *gcWork) tryGet() uintptr {
	...
			...
			wbuf = trygetfull() // 尝试从全局队列 work.full 中获取一个缓冲区
			...
	...
}

// trygetfull 尝试从全局队列 work.full 中获取一个缓冲区
// 如果没有立即可用的工作缓冲区，则返回 nil。
//
//go:nowritebarrier
func trygetfull() *workbuf {
	// 从 full 队列中尝试弹出一个工作缓冲区。
	b := (*workbuf)(work.full.pop())
	if b != nil {
		b.checknonempty() // 确保工作缓冲区不是空的。
		return b          // 返回找到的工作缓冲区
	}
	
	return b // 如果没有找到，则返回 nil。
}
```

从`trygetfull`: 全局队列 `work.full `中获取一个缓冲区

也就是说, 如果`work.full`没有了数据, 那么并发标记也就结束了, 所有对象都被扫描了一遍。

下面就可以进入标记终止阶段了。

#### gcMarkDone(): 将垃圾回收从标记阶段转换到标记终止阶段

##### **完整的`gcMarkDone` 方法**: 后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 函数用于将垃圾回收从标记阶段过渡到标记终止阶段，如果所有可达的对象已经被标记。
// 如果还有未标记的对象存在或未来可能有新对象产生，则将所有本地工作刷新到全局队列中，
// 使其可以被其他工作者发现并处理。
//
// 调用上下文必须是可以抢占的。
//
// 刷新本地工作非常重要，因为空闲的 P 可能有本地队列中的工作。这是使这些工作可见并驱动垃圾回收完成的唯一途径。
//
// 在此函数中显式允许使用写屏障。如果它确实转换到标记终止阶段，那么所有可达的对象都已被标记，
// 因此写屏障不会再遮蔽任何对象。
func gcMarkDone() {
	// 确保只有一个线程在同一时间运行 ragged barrier。
	semacquire(&work.markDoneSema)

top:
	// 在转换锁下重新检查转换条件。
	//
	// 关键是必须在执行 ragged barrier 之前检查全局工作队列是否为空。
	// 否则，可能存在全局工作，而 P 在通过 ragged barrier 后可能会获取这些工作。
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
		semrelease(&work.markDoneSema)
		return
	}

	// forEachP 需要 worldsema 执行，而我们稍后也需要它来停止世界，因此现在获取 worldsema。
	semacquire(&worldsema) // 获取stw世界信号量

	// 刷新所有本地缓冲区并收集 flushedWork 标志。
	gcMarkDoneFlushed = 0
	systemstack(func() {
		// 获取当前正在运行的 goroutine
		gp := getg().m.curg
		// 标记用户栈为可以抢占，以便它可以被扫描
		casGToWaiting(gp, _Grunning, waitReasonGCMarkTermination)

		// 遍历所有 P 线程调度器
		forEachP(func(pp *p) {
			// 刷新写屏障缓冲区，因为这可能会向 gcWork 添加工作。
			wbBufFlush1(pp)

			// 刷新 gcWork，因为这可能会创建全局工作并设置 flushedWork 标志。
			//
			// TODO(austin): 分解这些工作缓冲区以更好地分配工作。
			pp.gcw.dispose() // 将所有缓存的指针返回到全局队列
			// 收集 flushedWork 标志。
			if pp.gcw.flushedWork {
				atomic.Xadd(&gcMarkDoneFlushed, 1)
				pp.gcw.flushedWork = false
			}
		})

		// 转化线程状态
		casgstatus(gp, _Gwaiting, _Grunning)
	})

	// 检查是否存在更多灰色对象
	if gcMarkDoneFlushed != 0 {
		// 继续执行。有可能在 ragged barrier 期间转换条件再次变为真，因此重新检查。
		semrelease(&worldsema) // 释放stw世界信号量
		goto top
	}

	// 没有全局工作，没有本地工作，并且没有任何 P 通信了工作，自从获取了 markDoneSema。
	// 因此没有灰色对象，也不会有更多对象被遮蔽。转换到标记终止阶段。

	now := nanotime()                                           // 获取当前时间
	work.tMarkTerm = now                                        // 设置标记终止时间
	work.pauseStart = now                                       // 设置暂停开始时间
	getg().m.preemptoff = "gcing"                               // 设置不可抢占标志
	systemstack(func() { stopTheWorldWithSema(stwGCMarkTerm) }) // stw 停止世界

	restart := false // 初始化重启标志
	systemstack(func() {
		for _, p := range allp {
			wbBufFlush1(p)
			// 检查是否存在未完成的工作
			if !p.gcw.empty() {
				restart = true
				break
			}
		}
	})

	// 如果存在未完成的标记工作，则重新开始并发标记阶段
	if restart {
		getg().m.preemptoff = ""
		systemstack(func() {
			now := startTheWorldWithSema() // 函数用于恢复所有 goroutine 的执行。
			work.pauseNS += now - work.pauseStart
			memstats.gcPauseDist.record(now - work.pauseStart)
		})
		semrelease(&worldsema) // 释放stw世界信号量
		goto top
	}

	gcComputeStartingStackSize() // 用于计算新的 goroutines 启动时应分配的初始栈大小

	// 禁用协助和后台工作者。必须在唤醒被阻塞的协助之前这样做。
	atomic.Store(&gcBlackenEnabled, 0)

	// 通知 CPU 限制器 GC 协助现在将停止。
	gcCPULimiter.startGCTransition(false, now)

	gcWakeAllAssists() // 用于唤醒所有当前被阻塞的协助（assists）, 因为调度器 p 被 stw 暂停了,所以还不能调度

	// 同样，释放转换锁。被阻塞的工作者和协助将在启动世界时运行。
	semrelease(&work.markDoneSema)

	// 在 STW 模式下，重新启用用户 goroutines。这些将在 stw 启动世界后排队运行。
	schedEnableUser(true) // 函数用于启动用户 goroutine 的调度, 因为调度器 p 被 stw 暂停了,所以还不能调度

	// endCycle 依赖于所有 gcWork 缓存统计信息被刷新。
	// 上面的终止算法确保了从 ragged barrier 以来的所有分配。
	gcController.endCycle(now, int(gomaxprocs), work.userForced)

	// 从标记阶段过渡到标记终止阶段完成

	// 执行标记终止。
	gcMarkTermination()
}
```

##### **简化方法**:

```go
// 函数用于将垃圾回收从标记阶段过渡到标记终止阶段，如果所有可达的对象已经被标记。
// 如果还有未标记的对象存在或未来可能有新对象产生，则将所有本地工作刷新到全局队列中，
// 使其可以被其他工作者发现并处理。
//
// 调用上下文必须是可以抢占的。
//
// 刷新本地工作非常重要，因为空闲的 P 可能有本地队列中的工作。这是使这些工作可见并驱动垃圾回收完成的唯一途径。
//
// 在此函数中显式允许使用写屏障。如果它确实转换到标记终止阶段，那么所有可达的对象都已被标记，
// 因此写屏障不会再遮蔽任何对象。
func gcMarkDone() {
	...
	systemstack(func() { stopTheWorldWithSema(stwGCMarkTerm) }) // stw 停止世界
	...
	systemstack(func() {
		for _, p := range allp {
			wbBufFlush1(p)
			// 检查是否存在未完成的工作
			if !p.gcw.empty() {
				restart = true
				break
			}
		}
	})
    ...
	// 如果存在未完成的标记工作，则重新开始并发标记阶段
	if restart {
		getg().m.preemptoff = ""
		systemstack(func() {
			now := startTheWorldWithSema() // 函数用于恢复所有 goroutine 的执行。
			work.pauseNS += now - work.pauseStart
			memstats.gcPauseDist.record(now - work.pauseStart)
		})
		semrelease(&worldsema) // 释放stw世界信号量
		goto top
	}
	...
	// 从标记阶段过渡到标记终止阶段完成

	// 执行标记终止。
	gcMarkTermination()
}
```

从标记阶段过渡到标记终止阶段完成过程中

- 首先`stw`暂停世界, 在暂停的过程中, 遍历所有调度器 p,再次检测一次是否已经标记完成
- 如果`stw`暂停的过程中发现存在未完成的标记工作，则重新开始并发标记阶段
- 最终从标记阶段过渡到标记终止阶段完成, 执行标记终止

#### gcMarkTermination(): 执行标记终止

##### **完整的`gcMarkTermination` 方法**:

后面有简化的方法, 不纠结的可以看后面简化的方法

```go
// 函数用于完成垃圾回收周期的标记阶段，并重新启动世界。
// 该函数执行了标记终止阶段的多个步骤，包括最终标记, 清扫、统计更新、资源释放等。
func gcMarkTermination() {
	setGCPhase(_GCmarktermination) // 开始标记终止阶段（写屏障仍然启用）。

	// heapLive: 表示垃圾回收认为还活着的字节数
	work.heap1 = gcController.heapLive.Load()
	startTime := nanotime()

	// 获取当前的 m 结构体。
	mp := acquirem()
	mp.preemptoff = "gcing"
	mp.traceback = 2
	curgp := mp.curg

	// 最终标记

	// 将当前 goroutine 状态改为等待状态。
	casGToWaiting(curgp, _Grunning, waitReasonGarbageCollection)

	systemstack(func() {
		gcMark(startTime) // 系统确保所有可达对象都被正确标记，并为下一次垃圾回收周期做准备
		// 必须立即返回。
		// 外部函数的栈可能在 gcMark 过程中移动了（它会缩小栈，包括外部函数的栈），
		// 所以我们不能引用它的任何变量。返回非系统栈以获取新的地址再继续。
	})

	// 执行最终标记检查
	systemstack(func() {
		// 记录标记过程中扫描的字节数。
		work.heap2 = work.bytesMarked

		// 这段代码用于执行一个完全非并行的、停止世界的标记过程，目的是检查是否有对象在并发标记过程中被遗漏
		if debug.gccheckmark > 0 {
			startCheckmarks()             // 函数来初始化检查标记位。检查标记位是一种额外的机制，用来确保所有的可达对象都被正确地标记
			gcResetMarkState()            // 函数来重置标记状态。这通常意味着清除所有先前的标记信息，准备进行新的标记过程
			gcw := &getg().m.p.ptr().gcw  // 函数获取当前 goroutine 的结构体的 GC 工作缓冲区
			gcDrain(gcw, 0)               // 执行扫描工作，即黑化灰色对象
			wbBufFlush1(getg().m.p.ptr()) // 函数来清空写屏障缓冲区
			gcw.dispose()                 // 来释放 gcw，确保所有相关资源都被正确清理
			endCheckmarks()               // 函数来结束使用检查标记位的过程。这通常意味着清理所有与检查标记位相关的临时数据结构
		}

		setGCPhase(_GCoff) // 标记已完成，所以我们可以关闭写屏障。
		gcSweep(work.mode) // 正式回收垃圾, 因为调度器 p 被 stw 暂停了,所以还不能调度后台清扫 goroutine
	})

	mp.traceback = 0

	// 将当前 goroutine 状态改回运行状态。
	casgstatus(curgp, _Gwaiting, _Grunning)

	// 此时标记终止(最终标记)阶段已经完成

	// 更新统计信息和清扫状态

	if traceEnabled() {
		traceGCDone()
	}

	// 所有操作完成。
	mp.preemptoff = ""

	if gcphase != _GCoff {
		throw("gc done but gcphase != _GCoff")
	}

	// 记录 heapInUse 供 scavenger 使用。
	memstats.lastHeapInUse = gcController.heapInUse.load()

	systemstack(gcControllerCommit) // 重新计算所有步调参数，这些参数用于垃圾回收的触发阈值和堆的目标大小。为下一个周期做准备。

	// 更新与 GC 周期相关的统计信息，包括 GC 暂停时间、暂停时间分布、最近一次 GC 的时间戳以及 GC 过程中消耗的 CPU 时间
	now := nanotime()                                                                       // 函数获取当前时间点（纳秒精度）。
	sec, nsec, _ := time_now()                                                              // 函数获取当前时间的秒数和纳秒数。
	unixNow := sec*1e9 + int64(nsec)                                                        // 计算 Unix 时间戳（纳秒精度）
	work.pauseNS += now - work.pauseStart                                                   // 计算当前时间与上次记录的时间差
	work.tEnd = now                                                                         // 更新 work.tEnd 为当前时间点
	memstats.gcPauseDist.record(now - work.pauseStart)                                      // 录 GC 暂停时间分布
	atomic.Store64(&memstats.last_gc_unix, uint64(unixNow))                                 // 必须是 Unix 时间以对用户有意义
	atomic.Store64(&memstats.last_gc_nanotime, uint64(now))                                 // 单调时间用于内部使用
	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS) // 更新 GC 暂停时间数组
	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)    // 更新 GC 暂停结束时间数组
	memstats.pause_total_ns += uint64(work.pauseNS)                                         // 更新总的 GC 暂停时间

	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm) // 计算标记终止阶段消耗的 CPU 时间
	work.cpuStats.gcPauseTime += markTermCpu                           // 更新 GC 暂停时间统计
	work.cpuStats.gcTotalTime += markTermCpu                           // 更新 GC 总 CPU 时间统计

	// 累计 CPU 统计数据。
	// 传递 gcMarkPhase=true 以便我们可以获取最新的 GC CPU 统计数据。
	work.cpuStats.accumulate(now, true)

	// 计算总体 GC CPU 利用率。
	// 从总体利用率中排除空闲标记时间，因为它被认为是“免费”的。
	memstats.gc_cpu_fraction = float64(work.cpuStats.gcTotalTime-work.cpuStats.gcIdleTime) / float64(work.cpuStats.totalTime)

	// 重置协助时间和后台时间统计。
	//
	// 在这里重置，而不是在下一个 GC 周期开始时，因为即使 GC 不活跃，这两个也可能持续累加。
	scavenge.assistTime.Store(0)
	scavenge.backgroundTime.Store(0)

	// 重置空闲时间统计。
	sched.idleTime.Store(0)

	// 重置清扫状态。
	sweep.nbgsweep = 0
	sweep.npausesweep = 0

	if work.userForced {
		memstats.numforcedgc++
	}

	// 完成 GC 并唤醒等待的 goroutines

	// 增加 GC 周期计数并唤醒等待清扫的 goroutines。
	lock(&work.sweepWaiters.lock)
	memstats.numgc++
	injectglist(&work.sweepWaiters.list)
	unlock(&work.sweepWaiters.lock)

	// 增加 scavenger 生成。
	//
	// 这个时刻代表了峰值使用的堆，因为我们正要开始清扫。
	mheap_.pages.scav.index.nextGen()

	// 释放 CPU 限速器。
	gcCPULimiter.finishGCTransition(now)

	// 完成当前的堆剖析周期并开始一个新的堆剖析周期。
	// 我们在启动世界之前完成这个操作，以避免事件泄露到错误的周期。
	mProf_NextCycle()

	// 可能有需要清扫的过时 span 存在于 mcaches 中。
	// 这些不在任何清扫列表中，所以我们需要将它们计入清扫完成前的状态，直到确保所有的 span 都被强制清理。
	sl := sweep.active.begin()
	if !sl.valid {
		throw("failed to set sweep barrier")
	}

	systemstack(func() { startTheWorldWithSema() }) // stw启动世界。

	// 清空堆剖析数据以便开始新的周期。
	// 这个操作相对昂贵，所以我们不在世界停止时执行它。
	mProf_Flush()

	// 为清扫器准备释放 workbufs。我们异步执行这个操作，因为它可能需要一段时间。
	prepareFreeWorkbufs()

	// 释放栈 span。这必须在 GC 周期之间完成。
	systemstack(freeStackSpans)

	// 确保所有 mcaches 都被清空。每个 P 在分配之前都会清空自己的 mcache，但空闲的 P 可能不会。
	// 由于这是清扫所有 span 所必需的，我们需要在开始下一个 GC 周期之前确保所有 mcaches 都被清空。
	//
	// 当我们在处理这些时，清空空闲 P 的页面缓存以避免页面卡在那里。
	// 这些页面对 scavenger 是隐藏的，所以在小型空闲堆中可能会保留大量额外内存。
	//
	// 同时，清空 pinner 缓存，以避免无限泄漏这部分内存。
	systemstack(func() {
		forEachP(func(pp *p) {
			pp.mcache.prepareForSweep()
			if pp.status == _Pidle {
				systemstack(func() {
					lock(&mheap_.lock)
					pp.pcache.flush(&mheap_.pages)
					unlock(&mheap_.lock)
				})
			}
			pp.pinnerCache = nil
		})
	})

	// 现在我们已经清扫了 mcaches 中的过时 span，它们不再计入未清扫 span 的统计。
	sweep.active.end(sl)

	// 在释放 worldsema 之前打印 gctrace。一旦我们释放了 worldsema，另一个周期可能会开始并覆盖我们试图打印的统计信息。
	if debug.gctrace > 0 {
		util := int(memstats.gc_cpu_fraction * 100)

		var sbuf [24]byte
		printlock()
		print("gc ", memstats.numgc,
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
			util, "%: ")
		prev := work.tSweepTerm
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
			if i != 0 {
				print("+")
			}
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
			prev = ns
		}
		print(" ms clock, ")
		for i, ns := range []int64{
			int64(work.stwprocs) * (work.tMark - work.tSweepTerm),
			gcController.assistTime.Load(),
			gcController.dedicatedMarkTime.Load() + gcController.fractionalMarkTime.Load(),
			gcController.idleMarkTime.Load(),
			markTermCpu,
		} {
			if i == 2 || i == 3 {
				// 分隔标记时间的不同部分。
				print("/")
			} else if i != 0 {
				print("+")
			}
			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))
		}
		print(" ms cpu, ",
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
			gcController.lastHeapGoal>>20, " MB goal, ",
			gcController.lastStackScan.Load()>>20, " MB stacks, ",
			gcController.globalsScan.Load()>>20, " MB globals, ",
			work.maxprocs, " P")
		if work.userForced {
			print(" (forced)")
		}
		print("\n")
		printunlock()
	}

	// 设置任何被推迟到故障的 arena chunk。
	lock(&userArenaState.lock)
	faultList := userArenaState.fault
	userArenaState.fault = nil
	unlock(&userArenaState.lock)
	for _, lc := range faultList {
		lc.mspan.setUserArenaChunkToFault()
	}

	// 如果堆大小超过某个阈值，则在某些元数据上启用大页。
	if gcController.heapGoal() > minHeapForMetadataHugePages {
		systemstack(func() {
			mheap_.enableMetadataHugePages()
		})
	}

	semrelease(&worldsema) // 释放stw世界信号量
	semrelease(&gcsema)

	// 注意：现在可能会开始另一个 GC 周期。

	releasem(mp)
	mp = nil

	// 现在 GC 已完成，如果需要的话启动终结器线程。
	if !concurrentSweep {
		// 给排队的终结器一个运行的机会。
		Gosched()
	}
}
```

##### 简化方法

```go
// 函数用于完成垃圾回收周期的标记阶段，并重新启动世界。
// 该函数执行了标记终止阶段的多个步骤，包括最终标记, 清扫、统计更新、资源释放等。
func gcMarkTermination() {
	...
	// 最终标记
	systemstack(func() {
		gcMark(startTime) // 系统确保所有可达对象都被正确标记，并为下一次垃圾回收周期做准备
		// 必须立即返回。
		// 外部函数的栈可能在 gcMark 过程中移动了（它会缩小栈，包括外部函数的栈），
		// 所以我们不能引用它的任何变量。返回非系统栈以获取新的地址再继续。
	})

	// 执行最终标记检查
	systemstack(func() {
		// 记录标记过程中扫描的字节数。
		work.heap2 = work.bytesMarked

		// 这段代码用于执行一个完全非并行的、停止世界的标记过程，目的是检查是否有对象在并发标记过程中被遗漏
		if debug.gccheckmark > 0 {
			startCheckmarks()             // 函数来初始化检查标记位。检查标记位是一种额外的机制，用来确保所有的可达对象都被正确地标记
			gcResetMarkState()            // 函数来重置标记状态。这通常意味着清除所有先前的标记信息，准备进行新的标记过程
			gcw := &getg().m.p.ptr().gcw  // 函数获取当前 goroutine 的结构体的 GC 工作缓冲区
			gcDrain(gcw, 0)               // 执行扫描工作，即黑化灰色对象
			wbBufFlush1(getg().m.p.ptr()) // 函数来清空写屏障缓冲区
			gcw.dispose()                 // 来释放 gcw，确保所有相关资源都被正确清理
			endCheckmarks()               // 函数来结束使用检查标记位的过程。这通常意味着清理所有与检查标记位相关的临时数据结构
		}

		setGCPhase(_GCoff) // 标记已完成，所以我们可以关闭写屏障。
		gcSweep(work.mode) // 正式回收垃圾, 因为调度器 p 被 stw 暂停了,所以还不能调度后台清扫 goroutine
	})
    // 此时标记终止(最终标记)阶段已经完成

	// 更新统计信息和清扫状态
	...
	systemstack(gcControllerCommit) // 重新计算所有步调参数，这些参数用于垃圾回收的触发阈值和堆的目标大小。为下一个周期做准备。
	...
	// 完成 GC 并唤醒等待的 goroutines

	// 增加 GC 周期计数并唤醒等待清扫的 goroutines。
	lock(&work.sweepWaiters.lock)
	memstats.numgc++
	injectglist(&work.sweepWaiters.list)
	unlock(&work.sweepWaiters.lock)
	...
	systemstack(func() { startTheWorldWithSema() }) // stw启动世界。
	...
}
```

1. **进入标记终止阶段**:
    - 开始标记终止阶段，这是在并发标记之后进行的最终标记阶段。
    - 将当前 goroutine 的状态改为等待状态，以便准备进行标记终止。
2. **最终标记**:
    - 调用 `gcMark(startTime)` 函数来确保所有可达对象都被正确标记，并为下一次垃圾回收周期做准备。
    - 清空写屏障缓冲区，并确保所有缓冲的指针都被处理，所有的对象都被正确标记。
    - 如果启用了 `debug.gccheckmark`，则执行更详细的检查，确保缓冲区中的所有对象都已经被标记。
3. **记录已标记的字节数**:
    - 将 `work.bytesMarked` 的值赋给 `work.heap2`，记录标记过程中扫描的字节数。
4. **执行最终标记检查**:
    - 如果启用了 `debug.gccheckmark`，则执行最终标记检查，确保没有遗漏未标记的对象。
    - 初始化检查标记位。
    - 重置标记状态。
    - 获取当前 goroutine 的 GC 工作缓冲区。
    - 执行扫描工作，即黑化灰色对象。
    - 清空写屏障缓冲区。
    - 释放 GC 工作缓冲区。
    - 结束使用检查标记位的过程。
5. **关闭写屏障**:
    - 调用 `setGCPhase(_GCoff)` 关闭写屏障，因为标记已完成。
6. **执行垃圾清扫**:
    - 调用 `gcSweep(work.mode)` 来正式回收垃圾。因为调度器 `p` 被 STW 暂停了，所以还不能调度后台清扫 goroutine。
7. **更新统计信息和清扫状态**:
    - 更新与垃圾回收周期相关的统计信息，如暂停时间、CPU 使用情况等。
    - 清理与清扫相关的状态。
8. **重新计算步调参数**:
    - 调用 `systemstack(gcControllerCommit)` 来重新计算垃圾回收控制器的所有步调参数，这些参数用于决定何时触发下一次垃圾回收以及堆的目标大小。
9. **增加 GC 周期计数并唤醒等待清扫的 goroutines**:
    - 增加 GC 周期计数。
    - 唤醒等待清扫的 goroutines。
10. **启动世界**:
    - 调用 `systemstack(func() { startTheWorldWithSema() })` 来启动世界，结束 STW 模式，允许其他 goroutines 继续执行。

#### gcControllerCommit(): 重新计算所有步调参数

```go
// gcControllerCommit 是 gcController.commit 的包装函数，它传递来自实时（非测试）数据的参数。
// 它还更新了垃圾回收步调的任何消费者，如清扫步调和背景清扫器。
//
// 调用 gcController.commit。
//
// 必须持有堆锁，因此必须在系统栈上执行此函数。
//
//go:systemstack
func gcControllerCommit() {
	// 断言世界已停止或持有堆锁。
	assertWorldStoppedOrLockHeld(&mheap_.lock)

	gcController.commit(isSweepDone()) // 重新计算所有步调参数，这些参数用于导出垃圾回收的触发阈值和堆的目标大小。

	// 更新标记步调。
	if gcphase != _GCoff {
		gcController.revise()
	}

	// TODO(mknyszek): 这不再非常准确，因为堆目标是动态计算的。
	// 仍然有用作快照，但不如以前有用。
	if traceEnabled() {
		traceHeapGoal()
	}

	// 获取触发阈值和堆目标。
	trigger, heapGoal := gcController.trigger()

	// 根据触发阈值调整清扫步调。
	gcPaceSweeper(trigger)

	// 根据最新的步调参数调整背景清扫器。
	// 1. 当前的内存限制
	// 2. 堆目标
	// 3. 上一次的堆目标
	gcPaceScavenger(gcController.memoryLimit.Load(), heapGoal, gcController.lastHeapGoal)
}
```

#### commit(): 重新计算所有步调参数

```go
// 重新计算所有步调参数，这些参数用于导出垃圾回收的触发阈值和堆的目标大小。
//
// 这个方法可以在任何时候被调用。如果垃圾回收正在进行并发阶段，它将调整该阶段的步调。
//
// isSweepDone 应该是调用 isSweepDone() 的结果，除非我们在测试中或我们知道我们正在执行垃圾回收周期。
//
// 这个方法依赖于 gcPercent、gcController.heapMarked 和 gcController.heapLive。这些值必须是最新的。
//
// 如果垃圾回收已启用，调用者必须在调用此方法后调用 gcControllerState.revise。
//
// 必须持有 mheap_.lock 锁或停止世界。
func (c *gcControllerState) commit(isSweepDone bool) {
	if !c.test {
		assertWorldStoppedOrLockHeld(&mheap_.lock)
	}

	if isSweepDone {
		// 清扫已完成，因此无需考虑触发阈值的任何限制。
		c.sweepDistMinTrigger.Store(0)
	} else {
		// 并发清扫发生在从 gcController.heapLive 到触发阈值的堆增长中。
		// 确保清扫器有足够的跑道，如果它没有足够的空间。
		c.sweepDistMinTrigger.Store(c.heapLive.Load() + sweepMinHeapDistance)
	}

	// 计算下一次垃圾回收的目标大小，该目标是在上一个周期开始时的存活堆基础上，
	// 增长了 GOGC/100 的比例，再加上非堆来源的垃圾回收工作所需的额外空间。
	gcPercentHeapGoal := ^uint64(0)

	// 从 gcPercent 中加载当前的垃圾回收百分比设置。
	if gcPercent := c.gcPercent.Load(); gcPercent >= 0 {
		// 计算 gcPercentHeapGoal，即下一次垃圾回收的目标大小。
		// c.heapMarked 表示上次垃圾回收后标记的存活堆大小
		// c.lastStackScan.Load() 和 c.globalsScan.Load() 分别表示上次扫描栈和全局变量所消耗的空间
		gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*uint64(gcPercent)/100
	}
	// 应用最小堆大小。它是基于 gcPercent 定义的，并且只能通过调用 commit 的函数来更新。
	if gcPercentHeapGoal < c.heapMinimum {
		gcPercentHeapGoal = c.heapMinimum
	}
	// 存储计算得到的 gcPercentHeapGoal。
	c.gcPercentHeapGoal.Store(gcPercentHeapGoal)

	// 计算我们希望垃圾回收拥有的跑道量，使用我们对 cons/mark 比率的估计。
	//
	// 思路是采用我们预期的扫描工作，并乘以 cons/mark 比率来确定完成该扫描工作所需的时间，
	// 以字节分配的形式表示。这给了我们垃圾回收的跑道。
	//
	// 但是，cons/mark 比率是以每 CPU 秒的速率比率表示的，而在这里我们关心的是 CPU 资源
	// 在应用程序和垃圾回收之间分配的相对速率。
	//
	// 总结来说，我们拥有 B / cpu-ns，而我们想要的是 B / ns。我们通过乘以我们期望的 CPU 资源分配来获得它。
	// 我们选择以 GOMAXPROCS * fraction 的形式表达 CPU 资源。需要注意的是，因为我们这里处理的是比率，
	// 我们可以省略 CPU 核心的数量，因为它们会在分子和分母中出现并相互抵消。
	// 因此，这基本上只是根据我们期望的资源分配来“加权”cons/mark 比率。
	//
	// 此外，通过设置跑道使得 CPU 资源按照这种方式分配，假设 cons/mark 比率是正确的，
	// 我们就使得这种资源分配成为现实。
	c.runway.Store(uint64((c.consMark * (1 - gcGoalUtilization) / (gcGoalUtilization)) * float64(c.lastHeapScan+c.lastStackScan.Load()+c.globalsScan.Load())))
}
```

##### 垃圾回收计算公式说明

```go
gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*uint64(gcPercent)/100
```

**详细解释计算公式**:

- `c.heapMarked`: 上次垃圾回收后标记的存活堆大小。这是当前存活的对象所占用的内存总量。
- `c.lastStackScan.Load()`: 上次扫描栈所消耗的空间。这是因为栈上的对象也需要被扫描，以便确定它们是否仍然可达。
- `c.globalsScan.Load()`: 上次扫描全局变量所消耗的空间。全局变量同样需要被扫描以确定它们是否仍然可达。
- `gcPercent`: 垃圾回收百分比设置。这是一个配置参数，用于指定垃圾回收的目标是在堆大小增长到多少百分比时启动。

假设 `c.heapMarked` 为 100 MB，`c.lastStackScan.Load()` 为 10 MB，`c.globalsScan.Load()` 为 5 MB，`gcPercent` 为 80。

- `c.heapMarked` = 100 MB
- `c.lastStackScan.Load()` = 10 MB
- `c.globalsScan.Load()` = 5 MB
- `gcPercent` = 80%

计算过程如下：

1. 总和 = `c.heapMarked` + `c.lastStackScan.Load()` + `c.globalsScan.Load()` = 100 MB + 10 MB + 5 MB = 115 MB
2. 增长量 = `uint64(gcPercent)` / 100 * 总和 = 80 / 100 * 115 MB = 92 MB
3. `gcPercentHeapGoal` = `c.heapMarked` + 增长量 = 100 MB + 92 MB = 192 MB

因此，`gcPercentHeapGoal` 为 192 MB，这意味着当堆大小增长到 192 MB 时，垃圾回收将会启动。

### 5. 清理回收

```go
// 函数用于完成垃圾回收周期的标记阶段，并重新启动世界。
// 该函数执行了标记终止阶段的多个步骤，包括最终标记, 清扫、统计更新、资源释放等。
func gcMarkTermination() {
	...
	// 执行最终标记检查
	systemstack(func() {
		...
		gcSweep(work.mode) // 正式回收垃圾, 因为调度器 p 被 stw 暂停了,所以还不能调度后台清扫 goroutine
	})
    // 此时标记终止(最终标记)阶段已经完成
```

这里会调用`gcSweep`准备唤醒垃圾回收的后台线程。

```go
// gcSweep 负责垃圾回收的清扫阶段
// 它会设置清扫参数，并根据清扫模式选择同步清扫或后台清扫。
//
//	同步清扫会急切地清扫所有 span 并释放工作缓冲区。
//	后台清扫会唤醒清扫 goroutine 进行清扫。
//	这些步骤确保了垃圾回收器能够有效地清理未标记的对象，并准备好下一次垃圾回收周期。
//
// 世界必须处于停止状态。
//
//go:systemstack
func gcSweep(mode gcMode) {
	// 断言世界处于停止状态。
	assertWorldStopped()

	// 如果当前不在 GCoff 阶段，则抛出异常。
	if gcphase != _GCoff {
		throw("gcSweep being done but phase is not GCoff")
	}

	lock(&mheap_.lock)                    // 获取堆锁。
	mheap_.sweepgen += 2                  // 增加清扫代数。
	sweep.active.reset()                  // 重置清扫活动状态。
	mheap_.pagesSwept.Store(0)            // 重置已清扫的页面计数。
	mheap_.sweepArenas = mheap_.allArenas // 设置需要清扫的所有区域。
	mheap_.reclaimIndex.Store(0)          // 重置回收索引。
	mheap_.reclaimCredit.Store(0)         // 重置回收信用。
	unlock(&mheap_.lock)                  // 释放堆锁。

	sweep.centralIndex.clear() // 清除中央索引。
	...
	lock(&sweep.lock) // 获取清扫锁。

	// 后台清扫。
	if sweep.parked {
		sweep.parked = false    // 设置清扫状态为未停放。
		// sweep.g: 垃圾回收的 goroutine
		ready(sweep.g, 0, true) // 将清扫 goroutine 设置为可运行状态, 因为调度器 p 被 stw 暂停了,所以还不能调度后台清扫 goroutine
	}

	unlock(&sweep.lock) // 释放清扫锁。
}
```

这里最后也有一个故事: **将清扫 goroutine 设置为可运行状态, 因为调度器 p 被 stw 暂停了,所以还不能调度后台清扫 goroutine**

- 这个` sweep.g: 垃圾回收的 goroutine`是扫描时候创建的
- 如果`stw`结束, 调度器p, 单独到这个 goroutine 会执行扫描逻辑?

```go
// go 程序启动的主方法
func main() { // 这是主goroutine
	gcenable() // 负责启动垃圾回收的相关组件，并启用垃圾回收
	...
}
```

```go
// 函数在运行时初始化的大部分工作完成之后被调用，
// 在即将开始让用户代码运行之前。
// 它启动了后台清扫 goroutine、后台 scavenger goroutine，并启用了垃圾回收。
func gcenable() {
	// 启动清扫和 scavenger。
	c := make(chan int, 2) // 创建一个容量为 2 的通道。

	go bgsweep(c)    // 启动后台清扫 goroutine。
	go bgscavenge(c) // 启动后台 scavenger goroutine。

	<-c // 等待清扫 goroutine 准备完成发送信号。
	<-c // 等待 scavenger goroutine 准备完成发送信号。

	memstats.enablegc = true // 现在运行时已经初始化，垃圾回收可以开始了。
}
```

#### bgsweep(): 启动后台清扫 goroutine

```go
// 函数负责后台清扫 goroutine 的主体。负责清扫（sweep）垃圾回收器标记为不可达的对象所在的 span（内存块）
// 它会清扫 span，并在必要时让出时间。
// 通过这些步骤，这段代码确保了清扫 goroutine 能够有效地清扫 span，并在必要时让出时间，以避免过度占用 CPU 时间。
func bgsweep(c chan int) {
	sweep.g = getg() // 设置清扫 goroutine

	lockInit(&sweep.lock, lockRankSweep)                                   // 初始化清扫锁。
	lock(&sweep.lock)                                                      // 获取清扫锁。
	sweep.parked = true                                                    // 设置清扫状态为停放。
	c <- 1                                                                 // 通过通道发送信号，表示清扫 goroutine 已经启动。
	goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, 1) // 将清扫 goroutine 设置为等待状态。

	for {
		// 尝试作为一个“低优先级”的 goroutine，通过故意让出时间来实现。
		// 如果它没有运行也没关系，因为分配内存的 goroutine 会进行清扫，并确保所有 span 在下一次 GC 周期之前被清扫。
		// 我们只希望在空闲时运行它。
		//
		// 然而，在每次清扫 span 后调用 Gosched 会产生大量的跟踪事件，有时会占到跟踪事件的 50%。
		// 它还因为清扫单个 span 通常是一个非常快速的操作，通常只需要 30ns，在现代硬件上。
		// （见 #54767。）
		//
		// 结果，bgsweep 以批次方式清扫，并且只在每个批次结束时调用调度器。
		// 此外，它只有在其他核心上没有可用的空闲时间时才会让出时间。
		// 如果有可用的空闲时间，帮助清扫可以降低分配延迟，通过领先于按比例清扫，并使 span 为分配做好准备。

		const sweepBatchSize = 10 // 批次清扫的大小。
		nSwept := 0               // 清扫的 span 数量。
		for sweepone() != ^uintptr(0) {
			sweep.nbgsweep++ // 记录清扫次数。
			nSwept++         // 增加清扫的 span 数量。
			if nSwept%sweepBatchSize == 0 {
				goschedIfBusy() // 如果忙碌，则让出时间。
			}
		}
		for freeSomeWbufs(true) {
			// 注意：freeSomeWbufs 内部已经批量处理。
			goschedIfBusy() // 如果忙碌，则让出时间。
		}

		lock(&sweep.lock) // 获取清扫锁。

		// 函数检查清扫是否完成

		// 如果清扫未完成，则继续清扫
		if !isSweepDone() {
			unlock(&sweep.lock) // 释放清扫锁。
			continue            // 继续下一轮清扫。
		}

		// 如果清扫完成，则设置清扫状态为停放，并将清扫 goroutine 设置为等待状态
		sweep.parked = true                                                    // 设置清扫状态为停放。
		goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, 1) // 将清扫 goroutine 设置为等待状态。
	}
}
```

1. **初始化清扫 goroutine**:
    - 设置清扫 goroutine 的上下文，以便可以在清扫过程中访问当前 goroutine 的状态。
    - 初始化清扫锁，用于保护清扫状态。
    - 设置清扫状态为停放，表示清扫 goroutine 初始时处于停放状态。
    - 通过通道发送信号，表示清扫 goroutine 已经启动。
    - 将清扫 goroutine 设置为等待状态，等待清扫任务。
2. **清扫 span**:
    - 在一个无限循环中，清扫 span 并在必要时让出时间。
    - 每次清扫一个 span，都会记录清扫次数，以便统计清扫的工作量。
    - 以批次方式清扫 span，每清扫一定数量的 span（默认为 10 个 span）后，检查是否忙碌，如果是则让出时间，以避免过度占用 CPU
      时间。
3. **检查清扫状态**:
    - 获取清扫锁，以保护清扫状态不受其他 goroutine 的干扰。
    - 检查清扫是否完成。
    - 如果清扫未完成，则释放清扫锁并继续清扫。
    - 如果清扫完成，则设置清扫状态为停放，并将清扫 goroutine 设置为等待状态，等待下一次清扫任务。

ok! 垃圾回收的 goroutine 知道了, 一个“低优先级”的 goroutine, 真正清扫的是`sweepone`方法, 并且清扫的是 span。

```go
// 清扫某个未清扫的堆空间，并返回释放的页数，
// 如果没有可清扫的空间，则返回 ^uintptr(0)。
// 垃圾回收器会遍历所有的 span，并回收那些在标记阶段未被标记的对象所占用的空间
func sweepone() uintptr {
	...
	// 查找一个要清扫的空间。
	npages := ^uintptr(0)
	var noMoreWork bool
	for {
		...
			// 找到并获取要清扫的空间。
			npages = s.npages
			if s.sweep(false) {// 释放或收集未在标记阶段标记的块的终结器。它清除标记位，为下一轮 GC 做准备
				// 整个空间被释放。将其计入页面回收信用，因为这些页面现在可用于空间分配。
				mheap_.reclaimCredit.Add(npages)
			} else {
				// 空间仍在使用中，因此没有返回任何页面给堆，且空间需要移动到已清扫的使用中列表。
				npages = 0
			}
        ...
	}
	sweep.active.end(sl)
	...

	// 释放锁计数。
	gp.m.locks--
	return npages
}
```

在垃圾回收的最后关头, 我们来看看最后一个方法`sweep`: **释放或收集未在标记阶段标记的块**

#### sweep(): 释放未在标记阶段标记的块

```go
// sweep 释放或收集未在标记阶段标记的块的终结器。
// 它清除标记位，为下一次垃圾回收周期做准备。
// 如果 span 被归还到堆，则返回 true。
// 如果 preserve 为 true，则不将其归还到堆也不重新链接到 mcentral 列表中；
// 调用方会负责后续处理。
func (sl *sweepLocked) sweep(preserve bool) bool {
	// 关键：我们必须在这个函数开始时禁用抢占，
	// 垃圾回收不得在我们处理此函数的过程中启动。

	gp := getg()
	// 确保当前 goroutine 已经禁用了抢占。
	if gp.m.locks == 0 && gp.m.mallocing == 0 && gp != gp.m.g0 {
		throw("mspan.sweep: m is not locked")
	}

	s := sl.mspan
	if !preserve {
		// 我们将放弃对此 span 的所有权。将其设为 nil 以防调用方意外使用。
		sl.mspan = nil
	}

	sweepgen := mheap_.sweepgen
	// 检查 span 的状态是否为 mSpanInUse 并且 sweep 代号是否正确
	if state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen-1 {
		print("mspan.sweep: state=", state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
		throw("mspan.sweep: bad span state")
	}

	// 如果启用了追踪，则记录清扫 span 的统计信息
	if traceEnabled() {
		traceGCSweepSpan(s.npages * _PageSize)
	}

	mheap_.pagesSwept.Add(int64(s.npages))

	spc := s.spanclass
	size := s.elemsize

	// allocBits 指示哪些未标记的对象不需要处理，
	// 因为它们在上次 GC 周期结束时就是空闲的，并且此后没有被分配。
	// 如果 allocBits 索引 >= s.freeindex 且位未被标记，则对象自上次 GC 以来一直是未分配的。
	// 这种情况类似于对象在空闲列表上。

	// 解除链接并释放任何我们即将释放的对象的特殊记录。
	// 存在两个复杂性：
	// 1. 一个对象可以同时有终结器和剖析特殊记录。
	//    在这种情况下，我们需要排队执行终结器，
	//    标记对象为存活，并保留剖析特殊记录。
	// 2. 一个微小对象可以为不同偏移量设置多个终结器。
	//    如果此类对象未被标记，我们需要同时排队所有终结器。
	// 两种情况都可以同时发生。
	hadSpecials := s.specials != nil
	siter := newSpecialsIter(s)
	for siter.valid() {
		// 一个终结器可以为对象内部的某个字节设置，找到对象的起始位置。
		objIndex := uintptr(siter.s.offset) / size
		p := s.base() + objIndex*size
		mbits := s.markBitsForIndex(objIndex)

		// 此对象未被标记且至少有一个特殊记录。
		if !mbits.isMarked() {
			// 第一遍：查看它是否至少有一个终结器。
			hasFin := false
			endOffset := p - s.base() + size
			for tmp := siter.s; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
				if tmp.kind == _KindSpecialFinalizer {
					// 如果对象有终结器，则停止释放。
					mbits.setMarkedNonAtomic()
					hasFin = true
					break
				}
			}
			// 第二遍：排队所有终结器 _或_ 处理剖析记录。
			for siter.valid() && uintptr(siter.s.offset) < endOffset {
				// Find the exact byte for which the special was setup
				// (as opposed to object beginning).
				special := siter.s
				p := s.base() + uintptr(special.offset)
				if special.kind == _KindSpecialFinalizer || !hasFin {
					siter.unlinkAndNext()
					freeSpecial(special, unsafe.Pointer(p), size)
				} else {
					// 对象有终结器，因此我们保留它存活。
					// 其他所有特殊记录仅在对象释放时适用，
					// 因此只需保留特殊记录。
					siter.next()
				}
			}
		} else {
			// 如果对象被标记且有可达性特殊记录，则处理可达性记录
			if siter.s.kind == _KindSpecialReachable {
				special := siter.unlinkAndNext()
				(*specialReachable)(unsafe.Pointer(special)).reachable = true
				freeSpecial(special, unsafe.Pointer(p), size)
			} else {
				// 如果对象被标记且没有可达性特殊记录，则保留特殊记录
				siter.next()
			}
		}
	}

	// 如果 span 之前有特殊记录，现在没有了，则调用 spanHasNoSpecials 函数
	if hadSpecials && s.specials == nil {
		spanHasNoSpecials(s)
	}

	// 继续清扫 span 的剩余部分。
	if debug.allocfreetrace != 0 || debug.clobberfree != 0 || raceenabled || msanenabled || asanenabled {
		// 查找所有新释放的对象。这不需要高效；allocfreetrace 有巨大的开销。
		mbits := s.markBitsForBase()
		abits := s.allocBitsForIndex(0)
		for i := uintptr(0); i < s.nelems; i++ {
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
				x := s.base() + i*s.elemsize
				if debug.allocfreetrace != 0 {
					tracefree(unsafe.Pointer(x), size)
				}
				if debug.clobberfree != 0 {
					clobberfree(unsafe.Pointer(x), size)
				}
				// 用户 arena 在显式释放时处理。
				if raceenabled && !s.isUserArenaChunk {
					racefree(unsafe.Pointer(x), size)
				}
				if msanenabled && !s.isUserArenaChunk {
					msanfree(unsafe.Pointer(x), size)
				}
				if asanenabled && !s.isUserArenaChunk {
					asanpoison(unsafe.Pointer(x), size)
				}
			}
			mbits.advance()
			abits.advance()
		}
	}

	// 检查僵尸对象。
	if s.freeindex < s.nelems {
		// 所有 < freeindex 的都是已分配的，因此不可能是僵尸。
		//
		// 检查第一个位图字节，这里需要小心处理 freeindex。
		obj := s.freeindex
		if (*s.gcmarkBits.bytep(obj / 8)&^*s.allocBits.bytep(obj / 8))>>(obj%8) != 0 {
			s.reportZombies()
		}
		// 检查剩余的字节。
		for i := obj/8 + 1; i < divRoundUp(s.nelems, 8); i++ {
			if *s.gcmarkBits.bytep(i)&^*s.allocBits.bytep(i) != 0 {
				s.reportZombies()
			}
		}
	}

	// 计算 span 中空闲对象的数量。
	nalloc := uint16(s.countAlloc())
	nfreed := s.allocCount - nalloc
	if nalloc > s.allocCount {
		// 僵尸检查应该更详细地捕获这种情况。
		print("runtime: nelems=", s.nelems, " nalloc=", nalloc, " previous allocCount=", s.allocCount, " nfreed=", nfreed, "\n")
		throw("sweep increased allocation count")
	}

	s.allocCount = nalloc
	s.freeindex = 0 // 重置分配索引到 span 的起始位置。
	s.freeIndexForScan = 0
	if traceEnabled() {
		getg().m.p.ptr().trace.reclaimed += uintptr(nfreed) * s.elemsize
	}

	// gcmarkBits 成为 allocBits。
	// 为下次 GC 准备一个全新的清空的 gcmarkBits。
	s.allocBits = s.gcmarkBits
	s.gcmarkBits = newMarkBits(s.nelems)

	// 如果存在，则刷新 pinnerBits。
	if s.pinnerBits != nil {
		s.refreshPinnerBits()
	}

	// 初始化 alloc 缓存。
	s.refillAllocCache(0)

	// 检查 span 的状态，确保没有潜在的竞态条件。
	if state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen-1 {
		print("mspan.sweep: state=", state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
		throw("mspan.sweep: bad span state after sweep")
	}
	if s.sweepgen == sweepgen+1 || s.sweepgen == sweepgen+3 {
		throw("swept cached span")
	}

	// 设置 s.sweepgen = h.sweepgen 只有在所有块都被清扫后才能设置，
	// 因为可能存在并发 free/SetFinalizer 的情况。
	//
	// 但在我们使 span 可用于分配（将其归还到堆或 mcentral）之前必须设置它，
	// 因为分配代码假设如果 span 可用于分配，则已经清扫过。
	//
	// 序列化点。
	// 在这一点上，标记位已被清空，分配已准备好，
	// 所以释放 span。
	atomic.Store(&s.sweepgen, sweepgen)

	// 处理用户 arena。
	if s.isUserArenaChunk {
		if preserve {
			// 这是一种不应该由保留 span 以供重用的清扫器处理的情况。
			throw("sweep: tried to preserve a user arena span")
		}
		if nalloc > 0 {
			// 仍然存在指向 span 的指针或 span 尚未被释放。
			// 它还没有准备好重用。将其放回全清扫列表以供下一次周期使用。
			mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)
			return false
		}

		// 只有在此时清扫器实际上不再需要查看此 arena，
		// 所以现在从 pagesInUse 中减去。
		mheap_.pagesInUse.Add(-s.npages)
		s.state.set(mSpanDead)

		// arena 已准备好回收。从隔离列表中删除并放置在准备列表中。
		// 不再添加到任何清扫列表。
		systemstack(func() {
			// 到所有指向 chunk 的引用消失时，arena 代码有责任将 chunk 放在隔离列表上。
			if s.list != &mheap_.userArena.quarantineList {
				throw("user arena span is on the wrong list")
			}
			lock(&mheap_.lock)
			mheap_.userArena.quarantineList.remove(s)
			mheap_.userArena.readyList.insert(s)
			unlock(&mheap_.lock)
		})
		return false
	}

	// 处理小对象的 span。
	if spc.sizeclass() != 0 {
		if nfreed > 0 {
			// 只有当我们释放了一些对象时才标记 span 需要清零，
			// 因为新的 span 如果没有完全填充就被清扫，则所有空闲槽已经被清零。
			s.needzero = 1
			stats := memstats.heapStats.acquire()
			atomic.Xadd64(&stats.smallFreeCount[spc.sizeclass()], int64(nfreed))
			memstats.heapStats.release()

			// 在不一致的内部统计中计算释放的数量。
			gcController.totalFree.Add(int64(nfreed) * int64(s.elemsize))
		}
		if !preserve {
			// 直接将完全空闲的 span 归还到堆。
			if nalloc == 0 {
				// Free totally free span directly back to the heap.
				mheap_.freeSpan(s)
				return true
			}
			// 将 span 归还到正确的 mcentral 列表。
			if uintptr(nalloc) == s.nelems {
				mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)
			} else {
				mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)
			}
		}
	} else if !preserve {
		// 处理大对象的 span。
		if nfreed != 0 {
			// 将大对象 span 归还到堆。

			// 在一致的外部统计中计算释放的数量。
			//
			// 在 freeSpan 之前计算，因为它可能会更新 heapStats 的 inHeap 值。
			// 如果它这样做，那么从对象足迹中减去 inHeap 的指标可能会溢出。参见 #67019。
			stats := memstats.heapStats.acquire()
			atomic.Xadd64(&stats.largeFreeCount, 1)
			atomic.Xadd64(&stats.largeFree, int64(size))
			memstats.heapStats.release()

			// 在不一致的内部统计中计算释放的数量。
			gcController.totalFree.Add(int64(size))

			// 如果启用 efence，则使用 sysFault 代替 sysFree。
			if debug.efence > 0 {
				s.limit = 0 // 防止 mlookup 找到这个 span
				sysFault(unsafe.Pointer(s.base()), size)
			} else {
				mheap_.freeSpan(s)
			}
			return true
		}

		// 将大 span 直接放在全清扫列表上。
		mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)
	}
	return false
}
```

1. **检查状态**:
    - 确保当前 goroutine 已经禁用了抢占。
    - 检查 span 的状态是否为 `mSpanInUse` 并且 sweep 代号是否正确。
2. **记录清扫统计信息**:
    - 如果启用了追踪，则记录清扫 span 的统计信息。
3. **清扫特殊记录**:
    - 遍历 span 中的所有特殊记录。
    - 对于每个特殊记录，检查对应的对象是否被标记。
    - 如果对象未被标记且有终结器，则标记对象为存活，并处理终结器。
    - 如果对象未被标记且没有终结器，则释放特殊记录。
    - 如果对象被标记且有可达性特殊记录，则处理可达性记录。
    - 如果对象被标记且没有可达性特殊记录，则保留特殊记录。
4. **清理特殊记录**:
    - 如果 span 之前有特殊记录，现在没有了，则调用 `spanHasNoSpecials` 函数。
5. **处理特殊记录后的清扫**:
    - 如果启用了调试标志或竞态检测等，则查找所有新释放的对象，并处理相应的跟踪和调试功能。
6. **检查僵尸对象**:
    - 检查 span 中是否存在未被标记但已被分配的对象（僵尸对象）。
7. **统计信息更新**:
    - 更新分配计数和释放计数。
    - 如果启用了跟踪，则更新跟踪统计信息。
8. **标记位更新**:
    - 将 gcmarkBits 设置为 allocBits。
    - 为下次 GC 准备一个新的清空的 gcmarkBits。
9. **刷新 pinnerBits**:
    - 如果存在，则刷新 pinnerBits。
10. **初始化 alloc 缓存**:
    - 重置 alloc 缓存。
11. **状态检查**:
    - 确保 span 的状态正确。
12. **设置清扫代号**:
    - 更新 span 的清扫代号。
13. **处理用户 arena**:
    - 如果 span 是用户 arena 的一部分，则根据情况处理。
14. **处理小对象的 span**:
    - 如果 span 包含小对象，则根据释放数量决定是否需要清零。
    - 如果 span 完全空闲，则直接归还到堆。
    - 否则，将 span 归还到 mcentral 的适当列表。
15. **处理大对象的 span**:
    - 如果 span 包含大对象，则根据释放数量决定处理方式。
    - 如果 span 完全空闲，则直接归还到堆。
    - 否则，将 span 放在全清扫列表上。
16. **返回值**:
    - 根据 span 的处理情况返回适当的布尔值。



