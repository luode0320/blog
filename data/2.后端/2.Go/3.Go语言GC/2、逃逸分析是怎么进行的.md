# 简介

**逃逸分析是编译器用于决定将变量分配到栈上还是堆上的一种行为**。

逃逸分析的主要目的是提高程序的性能，通过减少不必要的堆分配和垃圾回收开销。



> 逃逸分析绝对是改善垃圾回收性能的主要关键点。而且逃逸分析由开发人员主观上是可以控制的。

- 如果我们尽量将变量控制在函数作用域内, 那么更多的对象就会被创建在系统栈上, 由函数执行完成被系统栈及时销毁。

- 就不需要依靠GC垃圾回收来处理垃圾, 大大的减少垃圾回收的性能开销。

# 原因

> 函数内分配的内存, 如果没有被外部引用, 就会被分配到栈上, 从而减少GC的压力。

众所周知，函数的运行都在操作系统内存空间中的栈空间内。

- 我们在栈上声明临时变量，分配内存，函数运行完毕后，回收内存。
- 每个函数的栈空间都是独立的，其他函数没有权限访问。
- 即使你是申请到的堆内存，如果发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多。
- 但在某些情况下，我们需要在函数结束以后访问栈上面的某些数据，这就涉及到**内存逃逸**了。



如果变量从栈上逃逸，那么他会逃到哪儿去呢？他会跑到堆上。

- 由于栈上的变量是在函数结束的时候自动进行回收，回收代价比较小；
- 而堆空间分配内存，则首先需要找到一块大小合适的内存，之后通过GC回收才能释放。
- 对于这种情况，频繁使用垃圾回收会占用比较大的开销，所以要尽量分配内存到栈上，减少GC的压力。



# 逃逸分析的工作原理

1. **编译期分析**: 逃逸分析在**编译期间**进行，而不是在运行时。这意味着编译器会检查程序的控制流图并分析变量的使用情况。
2. **变量作用域**: 如果一个变量的作用域仅限于当前函数，并且不会被返回或者传递给其他函数，那么它就不会逃逸，可以分配在栈上。
3. **函数返回**: 如果一个函数返回了对局部变量的引用，那么这个变量需要分配在堆上，因为其引用可能在函数之外被使用。
4. **闭包和匿名函数**: 如果一个闭包捕获了局部变量，并且这个闭包被返回或者存储在一个外部数据结构中，那么这个变量需要分配在堆上。
5. **全局变量**: 全局变量总是分配在堆上，因为它们在整个程序的生命周期内都是可访问的。
6. **不可确定的逃逸**: 如果编译器无法确定一个变量是否会逃逸，那么为了安全起见，它会被分配在堆上。
7. **指针和引用类型**: 如果一个指针或引用类型的变量指向了另一个变量，而这个指针或引用类型可能会被传递给其他函数或存储在外部结构中，那么这个被指向的变量也会被分配在堆上。



# 逃逸分析的好处

1. **减少垃圾回收开销**: 通过减少堆分配，可以降低垃圾回收的频率和开销。
2. **更快的内存分配**: 栈上的内存分配通常比堆上快得多，因为栈上的内存分配和释放是通过调整栈指针来实现的，而不需要复杂的内存管理逻辑。
3. **减少内存碎片**: 减少堆分配有助于减少内存碎片问题，从而提高程序的整体性能。



# 逃逸分析的限制

1. **精确性**: 逃逸分析可能不是完全精确的。在某些情况下，编译器可能过于保守，导致本可以分配在栈上的变量被分配在堆上。
2. **复杂性**: 逃逸分析增加了编译器的复杂性，并且可能会影响编译时间。



# 示例

```go
package main

import "fmt"

func createSlice() []int {
    s := make([]int, 10)
    return s
}

func main() {
    slice := createSlice()
    fmt.Println(slice)
}
```

在这个例子中，`createSlice` 函数返回了一个局部变量 `s` 的引用。

由于 `s` 的引用逃逸出了 `createSlice` 函数的范围，并且可以在 `main` 函数中被访问，所以 `s` 必须被分配在堆上。