# 简介

Go 语言的 goroutine 和传统的线程在多个方面存在差异，这些差异主要体现在调度、内存消耗、创建和销毁成本以及并发能力上。

详细解释这些区别：

- **调度方式**：
    - **线程**：由操作系统内核调度，这意味着线程的上下文切换涉及到内核态和用户态的转换，这会带来额外的开销。
        - 线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。线程切换，执行指令减少12000-18000
    - **goroutine**：由 Go 运行时的调度器调度，调度发生在用户态，避免了内核态切换，因此 goroutine 的上下文切换成本更低。
        - goroutine 的切换约为 200 纳秒，相当于 2400-3600 条指令

- **内存消耗**：
    - **线程**：每个线程通常有一个固定大小的栈，大约在几 MB 到几十 MB，这包括线程的本地数据和栈空间。
        - 创建一个 thread 则需要消耗约 1 MB 栈内存
    - **goroutine**：每个 goroutine 的初始栈空间非常小，大约 2KB，并且根据需要动态调整大小，这使得 goroutine 在内存使用上更加高效。
- **创建和销毁成本**：
    - **线程**：创建和销毁线程涉及内核操作，开销较大，尤其是由于内存分配和系统调用。
        - 销毁时间可能在毫秒（ms）到几十毫秒（ms）范围内
    - **goroutine**：创建和销毁 goroutine 由 Go 运行时处理，开销非常低，可以快速创建和销毁大量 goroutine。
        - 销毁时间可能在微秒（μs）到毫秒（ms）范围内
- **并发能力**：
    - **线程**：由于内存和调度开销，线程的并发数量通常受到限制。
    - **goroutine**：由于其轻量级特性，Go 程序可以轻松地支持数十万乃至更多 goroutine 的并发

# 为什么线程池不如 goroutine 的性能高？

线程池是为了减少线程创建和销毁的开销而设计的，通过重用线程而不是每次任务执行时都创建新线程。

然而，线程池仍然受限于每个线程的内存消耗和操作系统调度的成本。

相比之下，goroutine 的轻量化特性和运行时调度使其在高并发场景下具有更高的效率和响应速度。

# 示例

假设有一个任务，需要处理大量短小的工作单元，每个工作单元的计算非常快，但数量巨大。

- 使用线程池，每个工作单元都需要等待线程池中的线程空闲，而线程的切换和上下文恢复会带来明显的延迟。
- 使用 goroutine，你可以创建大量 goroutine 来并行处理这些工作单元，由于 goroutine 的轻量化，切换开销极低，可以更高效地利用
  CPU 资源。

例如，在 Go 中，你可以很容易地创建一个 goroutine 池来处理工作：

```go
package main

import (
	"fmt"
	"sync"
)

// worker 函数表示工作程序，接收一个工作任务并对其进行简单处理，然后将结果发送到结果通道
func worker(id int, jobs <-chan int, results chan<- int) {
	for job := range jobs {
		fmt.Printf("Worker %d got job %d\n", id, job)
		results <- job * 2 // 简单处理，将任务结果发送到结果通道
	}
}

func main() {
	jobs := make(chan int, 100)   // 创建一个缓冲大小为100的任务通道
	results := make(chan int, 100) // 创建一个缓冲大小为100的结果通道
	var wg sync.WaitGroup         // 声明一个同步等待组用于等待所有 goroutine 完成

	// 创建一个工作者池
	for w := 1; w <= 5; w++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			worker(id, jobs, results) // 每个工作者函数都会从任务通道获取任务并处理
		}(w)
	}

	// 向任务通道发送任务
	go func() {
		for j := 1; j <= 100000; j++ {
			jobs <- j
		}
		close(jobs) // 关闭任务通道，表示任务发送完成
	}()

	// 收集处理结果
	go func() {
		for a := 1; a <= 100000; a++ {
			<-results // 从结果通道接收处理结果（但实际并未做处理）
		}
		close(results) // 关闭结果通道，表示结果接收完成
	}()

	wg.Wait() // 等待所有工作者完成
}
```

在这个例子中，我们创建了一个 goroutine 池来处理大量工作单元，这比使用线程池更有效率，特别是在处理大量并发任务时。

尽管都是池化处理, 都是 goroutine 的切换会比普通的线程池要高效得多。

