# 简介

在 Go 语言中，通道（channel）的缓冲特性提供了在发送者和接收者之间存储数据的能力，从而允许一定程度的异步和非阻塞性操作。

无缓冲的 channel 通道是同步的，而有缓冲的 channel 通道是非同步的。

# 无缓冲demo

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 创建一个无缓冲的通道
	ch := make(chan int)

	// 启动一个 goroutine 来发送数据
	go func() {
		time.Sleep(1 * time.Second) // 等待一秒后发送数据
		ch <- 42                    // 发送数据到通道
		fmt.Println("Data sent.")
	}()

	// 主 goroutine 接收数据
	data := <-ch
	fmt.Println("Data received:", data)

	// 等待接收完数据后，程序正常退出
	fmt.Println("Program finished.")
}
```

在这个示例中：

- 我们首先创建了一个无缓冲的 `int` 类型通道 `ch`。
- 接着，我们启动了一个 goroutine，它会在一秒钟后向通道发送数字 `42`。
- 主 goroutine 会阻塞，直到从通道接收到数据。
- 由于通道是无缓冲的，发送操作（在 goroutine 中）和接收操作（在 main goroutine 中）都将阻塞，直到两者都准备就绪。
- 如果程序还没有执行到`data := <-ch`, 那么`ch <- 42 `会阻塞在这里。
- 强制发送者和接收者在数据传输时同步，这有助于避免竞态条件和确保数据的有序处理。

# 有缓冲demo

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 创建一个缓冲大小为 2 的通道
	ch := make(chan int, 2)

	// 启动一个 goroutine 来发送数据
	go func() {
		time.Sleep(1000 * time.Millisecond) // 等待1秒，让发送 goroutine 有时间发送数据
		ch <- 42                            // 发送第一个数据
		ch <- 100                           // 发送第二个数据
		fmt.Println("1. Data sent.")
	}()

	// 主 goroutine 接收数据, 通道为空会阻塞
	for i := 0; i < 2; i++ {
		data := <-ch
		fmt.Println("2. Received:", data)
	}

	// 等待接收完数据后，程序正常退出
	fmt.Println("3. Program finished.")
}
```

在这个示例中

- 一个 goroutine 尝试从一个空的、有缓冲的通道接收数据。
- 由于通道为空，接收操作被阻塞。
- goroutine 等待一秒后，向通道发送数据，此时被阻塞的接收操作可以继续执行并接收数据。

# 缓冲的特点

## 容量

当创建一个通道时，你可以指定其缓冲区的大小。

例如: 创建一个可以存储最多三个整数的缓冲通道。

```go
ch := make(chan int, 3)
```

## 非阻塞行为

缓冲通道允许发送者在没有立即接收者的情况下发送数据，只要缓冲区未满。

同样，接收者可以从缓冲通道中读取数据，即使没有立即的发送者，只要缓冲区中有数据。

## 阻塞边界

当缓冲区已满时，发送操作会阻塞，直到缓冲区中有空间（即至少有一个接收操作, 否则永远是满的）。

同样，当缓冲区为空时，接收操作会阻塞，直到缓冲区中有数据（即至少有一个发送操作, 否则永远都是空的）。

## 提高并发性能

缓冲通道可以提高程序的并发性能，因为它们减少了 goroutine 之间的直接同步需求。

发送者和接收者不必严格同步，这可以减少等待时间，使 goroutine 能够更快地执行其他任务。

## 避免死锁

使用缓冲通道可以更容易地避免死锁情况(无缓存通道容易发送死锁)。

- 在**无缓冲**通道

    - 如果 goroutine A 和 B 同时运行
    - 执行到 A 的发送操作的代码会阻塞
    - 直到 B 的接收操作代码被执行, A 和 B才能都停止阻塞
    - 如果 B 的代码因为其他原因未执行, A 出现死锁

- 在**有缓冲**的通道

    - 如果 goroutine A 和 B 同时运行
    - 执行到 A 的发送操作可以直接将数据放入缓冲区，而不需要 B 立即接收数据。
    - B 可以在任何方便的时候从缓冲区读取数据，而不需要 A 立即发送数据。
    - 不管0任何时候 A 都不会死锁

## 数据预加载

缓冲通道可以用于数据预加载。

例如，一个 goroutine 可以预先将数据放入缓冲通道中，而另一个 goroutine 可以在方便的时候处理这些数据，这可以提高数据处理的吞吐量。

## 控制流

缓冲通道可以用作控制信号, 是一个突然的限流器

例如，当缓冲区满时，可以视为一种流量控制信号，发送者应该暂停发送直到缓冲区有空位。

## 有限的资源池

缓冲通道可以用来实现有限的资源池，例如连接池或工作队列，其中缓冲区的大小限制了可用资源的数量。