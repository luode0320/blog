# 作用的类型

`cap` 函数可以应用于以下几种类型：

1. **切片（slices）**：`cap` 函数返回切片底层数组的容量。切片的容量是指切片可以增长的最大长度，而不需重新分配底层数组。
2. **数组指针（pointers to arrays）**：`cap` 函数返回数组指针指向的数组的长度，这与 `len` 函数返回的长度相同，因为数组的长度是固定的。
3. **通道（channels）**：`cap` 函数返回通道的缓冲大小。如果通道是非缓冲的，`cap` 将返回 0。

`cap` 函数的主要作用是帮助了解一个切片或通道的潜在扩展能力或已分配资源的大小。

这对于管理内存和优化程序性能非常有用。

# 示例

```go
package main

import (
	"fmt"
)

func main() {
	// 创建一个切片，并分配一个容量为 10 的底层数组，但初始长度为 5
	slice := make([]int, 5, 10)

	// 输出切片的长度和容量
	fmt.Printf("Slice len长度: %d, cap容量: %d\n", len(slice), cap(slice))

	// 创建一个有缓冲的通道，缓冲大小为 3
	ch := make(chan int, 3)

	// 输出通道的容量
	fmt.Printf("Channel cap容量: %d\n", cap(ch))
}
```

运行结果:

```sh
Slice len长度: 5, cap容量: 10
Channel cap容量: 3
```

在这个示例中：

- 我们创建了一个 `slice`，它的长度是 5，但容量是 10，意味着我们可以将 `slice` 的长度扩展到 10 而不需要重新分配底层数组。
- 我们创建了一个有缓冲的 `ch` 通道，其缓冲大小为 3，意味着通道可以存储 3 个元素而不会阻塞发送操作。

通过 `cap` 函数，我们可以知道切片可以扩展到多大，以及通道可以存储多少元素而不阻塞发送或接收操作。