# 简介

在 Go 语言中，当一个切片（slice）需要更多的空间来存储额外的元素时，它会尝试进行扩容。

切片扩容的规则取决于其底层数组的当前状态。

# 当切片还有剩余容量时

- 如果切片的长度（`len`）小于其容量（`cap`），那么通过 `append` 函数添加元素不会触发扩容，因为有足够的空间来容纳更多元素。
- 在这种情况下，扩容前后的切片实际上是相同的，即它们指向同一底层数组的同一部分。

# 当切片的容量达到极限时

- 当切片的长度等于其容量时，`append` 将触发扩容。Go 语言会根据当前的长度和容量决定新的容量大小。
- 容量如果小于等于256, 直接翻倍扩容，但在容量超过 256 元素后，增长因子会减小到 1.25（即增加当前容量的 25%）。
    - 这样可以减少频繁的内存分配和复制操作。
    - 超过256后并不是直接变成增加25%, 而是慢慢趋近于25%
        - 源码: `newcap += (newcap + 3*256) / 4`
- 在这种情况下，Go 会分配一个新的底层数组，将旧切片的数据复制到新数组中，然后使切片指向这个新数组。
    - 这意味着扩容前后，切片不再指向同一个底层数组。

# 例子

假设我们有一个切片 `s`，其长度为 2，容量为 5，指向底层数组 `[1 2 0 0 0]` 的前两个元素：

```go
package main

import "fmt"

func main() {
	s := []int{1, 2}
	fmt.Printf("append之前: %v, len: %d, cap: %d\n", s, len(s), cap(s))

	// 追加元素，但不会触发扩容，因为容量大于长度
	s = append(s, 3)
	fmt.Printf("append之后不调整大小: %v, len: %d, cap: %d\n", s, len(s), cap(s))

	// 再次追加元素，直到达到容量极限
	for i := 0; i < 2; i++ {
		s = append(s, i+4)
	}
	fmt.Printf("达到容量限制后: %v, len: %d, cap: %d\n", s, len(s), cap(s))

	// 追加元素，触发扩容
	s = append(s, 7)
	fmt.Printf("附加并调整大小后: %v, len: %d, cap: %d\n", s, len(s), cap(s))

	// 再次追加元素，直到达到容量极限
	for i := 0; i < 250; i++ {
		s = append(s, i+4)
	}
	fmt.Printf("达到容量256后: len: %d, cap: %d\n", len(s), cap(s))

	// 追加元素，触发扩容
	s = append(s, 7)
	fmt.Printf("附加并调整大小后:len: %d, cap: %d\n", len(s), cap(s))

	// 再次追加元素，直到达到容量极限
	for i := 0; i < 255; i++ {
		s = append(s, i+4)
	}
	fmt.Printf("达到容量512后: len: %d, cap: %d\n", len(s), cap(s))

	// 追加元素，触发扩容
	s = append(s, 7)
	fmt.Printf("附加并调整大小后:len: %d, cap: %d\n", len(s), cap(s))
}
```

运行结果:

```go
append之前: [1 2], len: 2, cap: 2
append之后不调整大小: [1 2 3], len: 3, cap: 4  
达到容量限制后: [1 2 3 4 5], len: 5, cap: 8    
附加并调整大小后: [1 2 3 4 5 7], len: 6, cap: 8
达到容量256后: len: 256, cap: 256              
附加并调整大小后:len: 257, cap: 512            
达到容量512后: len: 512, cap: 512              
附加并调整大小后:len: 513, cap: 848 
```

