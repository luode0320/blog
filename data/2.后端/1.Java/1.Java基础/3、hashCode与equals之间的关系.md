# hashCode()与equals()之间的关系

>  HashCode介绍：
>

- hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个int整数
- (相当于数组索引,用这个值去找哈希表数组对应的位置)
- Java 中的任何类都包含有hashCode() 函数。 
- 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。
- hashCode() 函数用key得到`数组索引`,数组位置存着一个链表的头节点,再把key-value存到链表中去!

**以“HashSet如何检查重复”为例⼦来说明为什么要有hashCode** 

- 对象加⼊HashSet时，HashSet会先计算对象的hashcode值来判断对象加⼊的`位置`(数组索引)，看该位置是否有 值(链表是否有数据)
- 如果没有,HashSet会假设对象没有重复出现。直接存。
- 但是如果发现有值，这时会调⽤`equals()⽅法`来检查两个对象是否真的相同。
  - 如果两者相同，HashSet就不会让其加⼊操作成功。
  - 如果不同的话，就不存呗!

>  如果两个对象相等，则hashcode⼀定也是相同的
>
>  两个对象有相同的hashcode值，它们也不⼀定是相等的 

- 因为hashcode函数再怎么也是拿着对象去做计算的,有特定的算法的

- 对象的每一个字符在码表(utf-8或者Ascll中对应的编码值)用`相同的算法`计算得到的数值一定是相同的
- 然而因为算法的问题,`不同的对象`计算的结果却不一定不一样,阴差阳错的情况下也可能相同,这得看写算法那个人的水平了(我给你写个算法,返回都为0😝)

>  两个对象相等,对两个对象分别调⽤equals⽅法都返回true 

>  equals⽅法被覆盖过，则hashCode⽅法也必须被覆盖 

- 这样做的目的是因为HashMap、HashSet和Hashtable这些数据结构
- 这些数据结构先用hashCode找到数组的索引位置,hashCode函数不变,所以数组的索引位置也不会变
- 然后用equals比较key,相同的key就替换,不同就添加到链表后边
- 本来equals比较相同key是替换,现在改写了equals,上次hashCode计算相同的key用这个equals可能不相同了
  - 追加到了链表后边,就出现了这个数据结构中出现了2个实际上是相同的key,之后get的时候有2个会出错的

>  hashCode()的默认⾏为是对堆上的对象产⽣独特值。如果没有重写hashCode()，则该class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据） 