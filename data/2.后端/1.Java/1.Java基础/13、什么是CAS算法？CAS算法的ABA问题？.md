# 什么是CAS算法？CAS算法的ABA问题？

**CAS是一种乐观锁技术，它能在`不使用锁`的情况下实现多线程安全, 所以CAS也是一种无锁算法。**

## 原理:

> CAS算法会在程序`最开始`读取一次要修改数据的值作为备份
>
> 程序执行到`最后一步`要完成对数据的修改提交之前,再次读取一次内存中的数据与第一次备份比较
>
> `(防止其他线程在算法计算的过程中修改了内存中的值)`
>
> 如果比较相同,则更新数据,不同则返回算法最开头,重新执行算法直到成功,`称为自旋`
>
> `(1.再读数据 2.过程计算 3.再次比较)`

```java
do{   
    备份旧数据；  
    基于旧数据构造新数据；  
}while(!CAS( 内存地址，备份的旧数据，新数据 ))  
```



1. 在内存地址V当中，存储着值为10的变量。

![图片](../../../picture\e84a204df31874968531c32f8bdda003.png)

2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。

![图片](../../../picture\b081ed4afa061dbfaac354b2faf400f9.png)

3. 在线程1要`提交更新之前(最后一步)`，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。

![图片](../../../picture\41f1680b4612a4c7c13754e07e72ef7f.png)

4. 线程1开始提交更新，首先进行**A和地址V的实际值比较（Compare）**，发现A(10)不等于V的实际值(11)，提交失败。

![图片](../../../picture\c69e231e96f785ef6a1b9d0d061b22ad.png)

5. 线程1重新获取内存地址V的当前值，并`重新计算(返回方法起点重新开始)`想要修改的新值。此时对线程1来说，A=11，B=12(最后应该要修改成的值)。这个重新尝试的过程被称为**自旋**。

![图片](../../../picture\6cdc55ef1a8af0c3e3c17341e18c2a4d.png)

6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行**Compare**，发现A和地址V的实际值是相等的。

![图片](../../../picture\fe7269841a80202463424b323a510382.png)

7. 线程1进行交换操作，把地址V的值替换为B，也就是12。

![图片](../../../picture\ca92615e41d6eff6f0015edd1a0b421f.png)

`Atomic操作类`的底层正是用到了"CAS机制"。`AtomicInteger`当中常用的自增方法 **incrementAndGet：**

```java
public final int incrementAndGet() {
    for (;;) {
        //第一次读取备份
        int current = get();
        //计算出目标值
        int next = current + 1;
        //进行CAS操作比较备份值(current)与此时内存值,相同则跳出循环，如果失败则重复上述步骤。
        //这个方法会调用底层操作系统,会保证原子性操作,多线程同时执行不会带来问题
        if (compareAndSet(current, next))
            return next;
    }
}
//volatile关键字: 保证获得的当前值是内存中的最新值
private volatile int value;
public final int get() {
    return value;
}
```

##  CAS的缺点：

### 1.CPU开销较大

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。



### 2.不能保证代码块的原子性

CAS机制所保证的只是`一个变量`的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了(因为他只是对一个地址做控制,多个地址就要使用多个CAS,不能保证同步)。



### 3.ABA问题

> 所谓ABA问题，就是一个内存中变量的值,从A改成了B,又从B改成了A
>
> 备份值和内存值相同会`让线程以为`这个值没有被改变过

**假设**

- 你有一个盛满水的杯子
- 你是线程1,我是线程2,杯子是数据结构,杯子里的水是数据
- 我把水倒出来,之后我再倒回去,然后你喝掉水
  - 从结果来看: `我和杯子好像干了点什么,又好像没干,根本不影响结果`
  - 从过程来看: `我动过这个杯子`

**为什么说这样会有问题呢?到底有什么问题?**

> 1. ABA的场景出现时，备份值和内存值相同会`让线程以为`这个值没有被改变过。
>
> 2. 然而`“值相同 = 没有被改变过”`这个结论无法成立，即使第二个线程确确实实改过这个值，只不过又改回来了,依旧无法保证是没有被改变过的
>
> 3. 那么“值曾经发生过改动”这个事件就无法被观测到。

- `对于需要跟踪值的改变过程（比如记录值改变的次数）的场景来说ABA问题就是致命的。`
	- 老婆出轨之后又回到了你身边，还是你原来的那个老婆吗？
- 如果你的需求`不需要跟踪改变过程,ABA就不是问题`

> 简而言之
>
> - 如果你`必须要看到数据变化的过程`,而不仅仅只看一个结果时,请不要单纯的去使用CAS机制
>   - CAS机制的ABA问题是非常致命的,它是不能让你看到过程的,你只能得到一个结果
> - 如果`只是在意结果`,那么CAS机制将非常优秀

**怎么解决ABA问题?**

- 当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。

- 利用版本号比较可以有效解决ABA问题。

> 怎么加上版本号? 使用AtomicStampedReference

```java
String[] b = {"b","bb","bbb","bbbb"};
AtomicStampedReference<String[]> aAtomic = new AtomicStampedReference<>(b,0);

//casTabAt(数组,数组索引,期望值,被替换的值)
AtomicStampedReference[] data;
casTabAt(data,数组索引,aAtomic,aAtomic2)
```
  >`大帅比,点赞了没?`