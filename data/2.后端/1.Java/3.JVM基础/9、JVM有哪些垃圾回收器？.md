# JVM有哪些垃圾回收器？ 

> 第一阶段: `Serial (串行) 收集器` -> 时间在JDK1.3左右

- 新⽣代(Serial---标记-复制算法)	⽼年代(SerialOld---标记-整理算法)  -> 开启配置如下 ↓

  ```shell
  -XX:+UseSerialGC
  ```

> 第二阶段: `Parallel (并行) 收集器` -> JDK 6中才开始提供,JDK 8中默认使用

- Parallel收集器也称吞吐量收集器,使用多线程去完成垃圾清理工作

- 新⽣代(Parallel---标记-复制算法)	⽼年代(ParallelOld---标记-整理算法) -> 开启配置如下 ↓

  ```shell
  -XX:+UseParallelGC -XX:+UseParallelOldGC
  ```

> 第三阶段: `CMS（并发）收集器` -> JDK 5出现,JDK 9 已经宣布废除 CMS 垃圾收集器

- CMS收集器在Minor(年轻代) GC时会`暂停所有的应用线程`，并以多线程的方式进行垃圾回收。

- 在老年代 GC时`不再暂停应用线程`，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。

- 新⽣代(ParNew---标记-复制算法)	⽼年代(ConcMarkSweep---标记-清除算法) -> 开启配置如下 ↓

  ```shell
  -XX:+UseParNewGC -XX:+UseConcMarkSweepGC
  ```

> 第四阶段: `G1（并发）收集器` -> JDK 8之后广泛使用,JDK 9 默认用G1收集器

- G1收集器（或者垃圾优先收集器）的设计初衷是为了`尽量缩短`处理**超大堆**（大于4GB）时产生的停顿。

- 相对于CMS的优势而言是`降低内存碎片的产生`。

- 标记-复制算法 + 标记-整理算法 -> 开启配置如下 ↓

  ```shell
  -XX:+UseG1GC
  ```

**注意**:

- 并行GC:多条垃圾回收线程同时操作 
- 并发GC:垃圾回收线程与用户线程一起轮询操作

- 串行GC:一条垃圾回收线程 

> `点赞,靓仔!!!`