# 6⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？ 

1. ⾸先类加载器把`字节码⽂件内容加载到⽅法区`,当然类加载器这中间用`双亲委派机制`加载
2. 然后再根据加载完方法区中的类信息在堆区`为对象分配内存丶初始化零值丶设置对象头丶执行 init 方法`
   1. 分配内存: 确定大小的内存从 Java 堆中划分出来
   2. 初始化零值: 将分配到的内存空间都初始化为零,这样对象只定义,不初始化也可以用
   3. 设置对象头: 对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等
   4. 执行 init 方法: 最后就是调用构造方法了,初始化对象,完成创建
3. 对象⾸先会分配在`堆内存中新⽣代的Eden`。
   - 小对象分配在`新⽣代的Eden`。然后经过`新生代GC`，对象如果存活，就会进⼊S区。
     - 在后续的每次GC中，如果对象⼀直存活，就会在S区来回拷⻉，每移动⼀次，年龄加1。
     - 多⼤年龄才会移⼊⽼年代？ 年龄最⼤15， 超过⼀定年龄后，对象转⼊⽼年代。 
   - 对象够大,分配在`老年代`
     - JDK 6 之前存在空间担保 -> 老年代保证我会保留一个连续内存大小的内存空间
       - 如果内存不够,你就可以FullGC,还不够内存溢出
       - 如果内存够,那就存进去
     - JDK 6 之后 -> 老年代的连续空间大于`新生代对象总大小或者历次晋升的平均大小(动态年龄)`
       - 如果内存不够,你就可以FullGC,还不够内存溢出
       - 如果内存够,那就存进去
4. 当创建对象的⽅法执⾏结束后，栈中的指针会先移除掉了,对象就没有`GC Roots`根节点的引用了
5. 然后GC根据`可达性分析法`,判断对象是否可以被回收
6. 最后GC线程`调用合适的GC算法`清理掉可回收的对象