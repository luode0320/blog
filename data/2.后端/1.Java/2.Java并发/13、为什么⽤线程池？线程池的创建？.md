# 为什么⽤线程池？线程池的创建？ 

> 为什么⽤线程池？

- 随着系统越来越大丶业务越来越复杂,就需要多线程来配合工作,提升系统的性能
- 创建一个线程的方法网上说有好几种
  - 实现runnable丶callable丶继承Thread类
  - 实际上看起来就只有一种
  - 就是`new 一个Thread线程对象`,那两个接口仅仅只是用来`重写run方法实现业务逻辑的`
- 所以线程最基础的步骤就是`创建一个线程对象`,就是线程生命周期的第一步,创建状态
- 就跟数组有工具类丶集合有工具类一样,线程为了简化步骤,肯定有自己的工具类
- 就是线程池,线程池的好处网上一大堆
  - 降低资源消耗；`降低创建和销毁线程的消耗`。 
  - 提⾼响应速度；任务来了，直接`有线程可⽤可执⾏，⽽不是先创建线程，再执⾏`。 
  - 提⾼线程的可管理性；线程是稀缺资源，使⽤`线程池可以统⼀分配调优监控`。 
- 我们甚至都不用考虑这么多,只需要知道这是一个线程的工具类就行了
- 它可以`简化创建线程的步骤,对执行线程有更好的优化作用`
- 所以我们在`一般情况下都应该使用线程池`,只在某些`非常特殊时期才选择使用最原始方式去创建线程`

> 线程池的创建

- 我们可以通过java.util.`concurrent.ThreadPoolExecutor`(线程池执行器)来创建一个线程池。
- 参数我就记不得了,谁没事回去记参数啊是不是,死记硬背一点用也没有
  - 大概知道参数肯定有`初始的线程数量丶最大可扩展的线程数量丶线程超时时间丶线程等待队列`这些参数
  - 具体的用的时候在看,这是一个很典型的`生产者-消费者模式`
  - **线程池就是生产者**,我们任务需要**线程就是消费者**
  - 需要的线程太多了,线程池作为生产者就可以扩大线程数量
- 当然还有线程池的执行器工具类,用来更加方便的创建一个线程池 -> `Executors`
  - 执行器工具类算就是一个`简单工厂模式`
  - 调用不同的静态方法,传递不同参数来创建不同的线程池

