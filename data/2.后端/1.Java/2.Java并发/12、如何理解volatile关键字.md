# 如何理解volatile关键字

> 变量对所有线程总是可⻅的

- 保证被volatile修饰的共享变量对所有线程总是可⻅的，也就是当⼀个线程修改了⼀个被volatile修饰共享变量的值，新值总是可以被其他线程⽴即得知。 
  - 因为cpu执行一般来说是`有缓存的`,一级二级三级缓存之后才到真正的内存
  - 对一个变量进行修改,会先走一级 ->  二级 -> 三级再到内存的步骤
  - 所以**不会直接修改到内存的值**
  - 如果要`⽴即看到值的修改`就`禁用缓存`或者`跳过缓存`直接修改内存中的数据

- `volatile`可以简单的理解为,对这个关键字修饰的变量,`会直接修改内存中的值,会直接读取内存中的值`,不会经过缓存
- 使⽤volatile关键字会`强制将修改的值⽴即写⼊主存`； 

> 禁⽌指令重排序优化 

- JVM 存在**指令重排**，`volatile`关键字可以使程序`严格按照代码的先后顺序执行`。
- 而使用了`volatile`关键字的变量的一些操作`就不会出现指令重排`
- 例如: 并发包下的ConcurrentHashMap中记录map中有多少个k-v键值对时,每put一次都会加1,这个成员变量size一定是加了volatile修饰的,禁⽌指令重排,程序什么时候决定可以将总数加1了,就执行,而不是重排到最前面或者最后面

