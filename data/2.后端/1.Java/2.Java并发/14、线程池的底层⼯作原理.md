# 线程池的底层⼯作原理 

> 线程池内部是通过队列+线程实现的，当我们利⽤线程池执⾏任务时： 

1. 如果此时线程池中的线程数量`⼩于corePoolSize`，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 
   - 线程池最少也要保留制定的线程数量

2. 如果此时线程池中的线程数量`等于corePoolSize`，但是缓冲队列`workQueue未满`，那么任务被放⼊缓冲队列。 
   - 工作队列未满,多出来的任务要先加入工作队列

3. 如果此时线程池中的线程数量`⼤于等于corePoolSize`，缓冲队列`workQueue满`，并且线程池中的数量`⼩于maximumPoolSize`，建新的线程来处理被添加的任务。 
   - 工作队列满了,就要新建线程,都是线程允许的数量最大值有规定

4. 如果此时线程池中的线程数量`⼤于corePoolSize`，缓冲队列`workQueue满`，并且线程池中的数量`等于maximumPoolSize`，那么通过 handler所指定的策略来处理此任务。 
   - 任务过多,执行错误处理程序

5. 当线程池中的线程数量`⼤于 corePoolSize`时，如果某线程`空闲时间超过keepAliveTime`，线程将被终⽌。这样，线程池可以动态的调整池中的线程数
   - 线程数量新建了,但是后来没有任务用了,就销毁多出来的线程

# 线程池中线程复⽤原理 

- 当我们每调用`execute丶submit方法`的时候,就是把一个任务推到线程池
- 就是把一个`run方法`推到线程池,线程池**会根据情况直接执行这个方法还是加入阻塞队列**

- 当有**空闲线程**的时候,这个空闲线程`去执行run方法`,或者去阻塞队拿一个run方法出来调用

- 原理其实就是,我们`提交的任务就是一个普通的run方法`
- 线程池里面的`空闲线程去执行我们提交的run方法`