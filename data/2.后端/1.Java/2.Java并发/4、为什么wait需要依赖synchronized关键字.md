# 为什么wait需要依赖synchronized关键字

> 答案: `synchronized的作用是给对象加锁`

- wait丶notify需要一个加锁的对象状态

- 这个问题其实跟为什么wait 是 Object 类的本地方法?是一个道理
- 我们要知道wait丶notify是用来线程通信的
- 而什么叫做`线程通信`?
- 是我们`多个线程完成一个任务`的时候,需要线程互相协作,一个线程通知另外一个指定线程开始工作

- 所以线程通信要通信什么? 
- 线程之间什么是两个线程共有的,用这个共有的东西,去控制是该执行这个线程还是那个线程?
- 答:是通信数据,通信的数据是线程共有的数据丶共有的对象
- 这样我们使用线程`共同拥有的对象`,在不同的代码块里,判断同一个对象的状态,去控制不同线程之间协调工作
- 那这个对象的状态用什么来区分最合适?
- 答案是: 是否加锁,是否获取到锁,并且锁还有另一个好处,可以保证数据的一致性,多个线程共同操作一个数据,保证数据一致性是非常重要的

> 所以wait需要依赖synchronized关键字,wait 在线程通信之间`必须要以加锁的状态`来判断具体使用哪个线程

- 要有锁才能完成不同线程之间的通信,用锁的状态去控制线程切换
  - 没有获取到锁,线程请进入对象内部锁的入口集合,竞争锁
  - 获取到锁,调用wait,线程进入对象内部锁的等待集合,等待notify唤醒
- `线程通信的绝对必要条件 -> 锁`