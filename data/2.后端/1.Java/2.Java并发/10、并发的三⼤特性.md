# 并发的三⼤特性 

**原⼦性 丶可⻅性 丶有序性** 

>  原⼦性 

- 一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。
- 并发的原⼦性是**线程对一个数据进行操作**,要么线程完成`数据整个流程的操作`,要么这个线程对这个`数据一步都不操作`。

关键字：`synchronized `

- synchronized可以保证线程对一个`数据操作流程的完整性,即原⼦性 `

> 可⻅性 

- 当多个线程`访问同⼀个变量`时，⼀个线程修改了这个变量的值，其他线程能够`⽴即看得到修改的值`。 
  - 为什么会出现可⻅性的问题?
  - 因为cpu执行一般来说是`有缓存的`,一级二级三级缓存之后才到真正的内存
  - 对一个变量进行修改,会先走一级 ->  二级 -> 三级再到内存的步骤
  - 所以**不会直接修改到内存的值**
  - 多个线程之间要`⽴即看到值的修改`就`禁用缓存`或者`跳过缓存`直接修改内存中的数据

关键字：`volatile`

- volatile可以简单的理解为,对这个关键字修饰的变量,`会直接修改内存中的值,会直接读取内存中的值`,不会经过缓存

> 有序性 

- 即程序执行的顺序`严格按照代码的先后顺序执行`。
- JVM 存在**指令重排**，所以存在有序性问题。

关键字：`volatile`

- **volatile**关键字，禁止`被它修饰的变量`发生指令重排操作。
  - 例如: 并发包下的ConcurrentHashMap中记录map中有多少个k-v键值对时,每put一次都会加1,这个成员变量size一定是加了volatile修饰的,禁⽌指令重排,程序什么时候决定可以将总数加1了,就执行,而不是重排到最前面或者最后面
- 也有说synchronized也保证了有序性的,是因为synchronized保证了加锁的代码块之间是有序的,`只有获得锁的那块代码才可以执行`

